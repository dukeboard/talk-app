{"version":3,"sources":["fake","vs/loader.js","vs/css.js","vs/nls.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACx5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACteA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"vs/loader.js","sourcesContent":["/*!-----------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.6.1(8f43cf5d0d3d233c9ba1c9085f2bb529f834c841)\n * Released under the MIT license\n * https://github.com/Microsoft/vscode/blob/master/LICENSE.txt\n *-----------------------------------------------------------*/\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/*---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n * Please make sure to make edits in the .ts file at https://github.com/Microsoft/vscode-loader/\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n// Limitation: To load jquery through the loader, always require 'jquery' and add a path for it in the loader configuration\nvar _amdLoaderGlobal = this, define;\nvar AMDLoader;\n(function (AMDLoader) {\n    // ------------------------------------------------------------------------\n    // Utilities\n    function _isWindows() {\n        if (typeof navigator !== 'undefined') {\n            if (navigator.userAgent && navigator.userAgent.indexOf('Windows') >= 0) {\n                return true;\n            }\n        }\n        if (typeof process !== 'undefined') {\n            return (process.platform === 'win32');\n        }\n        return false;\n    }\n    var isWindows = _isWindows();\n    var Utilities = (function () {\n        function Utilities() {\n        }\n        /**\n         * This method does not take care of / vs \\\n         */\n        Utilities.fileUriToFilePath = function (uri) {\n            uri = decodeURI(uri);\n            if (isWindows) {\n                if (/^file:\\/\\/\\//.test(uri)) {\n                    // This is a URI without a hostname => return only the path segment\n                    return uri.substr(8);\n                }\n                if (/^file:\\/\\//.test(uri)) {\n                    return uri.substr(5);\n                }\n            }\n            else {\n                if (/^file:\\/\\//.test(uri)) {\n                    return uri.substr(7);\n                }\n            }\n            // Not sure...\n            return uri;\n        };\n        Utilities.startsWith = function (haystack, needle) {\n            return haystack.length >= needle.length && haystack.substr(0, needle.length) === needle;\n        };\n        Utilities.endsWith = function (haystack, needle) {\n            return haystack.length >= needle.length && haystack.substr(haystack.length - needle.length) === needle;\n        };\n        // only check for \"?\" before \"#\" to ensure that there is a real Query-String\n        Utilities.containsQueryString = function (url) {\n            return /^[^\\#]*\\?/gi.test(url);\n        };\n        /**\n         * Does `url` start with http:// or https:// or / ?\n         */\n        Utilities.isAbsolutePath = function (url) {\n            return (Utilities.startsWith(url, 'http://')\n                || Utilities.startsWith(url, 'https://')\n                || Utilities.startsWith(url, 'file://')\n                || Utilities.startsWith(url, '/'));\n        };\n        Utilities.forEachProperty = function (obj, callback) {\n            if (obj) {\n                var key;\n                for (key in obj) {\n                    if (obj.hasOwnProperty(key)) {\n                        callback(key, obj[key]);\n                    }\n                }\n            }\n        };\n        Utilities.isEmpty = function (obj) {\n            var isEmpty = true;\n            Utilities.forEachProperty(obj, function () {\n                isEmpty = false;\n            });\n            return isEmpty;\n        };\n        Utilities.isArray = function (obj) {\n            if (Array.isArray) {\n                return Array.isArray(obj);\n            }\n            return Object.prototype.toString.call(obj) === '[object Array]';\n        };\n        Utilities.recursiveClone = function (obj) {\n            if (!obj || typeof obj !== 'object') {\n                return obj;\n            }\n            var result = Utilities.isArray(obj) ? [] : {};\n            Utilities.forEachProperty(obj, function (key, value) {\n                if (value && typeof value === 'object') {\n                    result[key] = Utilities.recursiveClone(value);\n                }\n                else {\n                    result[key] = value;\n                }\n            });\n            return result;\n        };\n        Utilities.generateAnonymousModule = function () {\n            return '===anonymous' + (Utilities.NEXT_ANONYMOUS_ID++) + '===';\n        };\n        Utilities.isAnonymousModule = function (id) {\n            return id.indexOf('===anonymous') === 0;\n        };\n        Utilities.NEXT_ANONYMOUS_ID = 1;\n        return Utilities;\n    }());\n    AMDLoader.Utilities = Utilities;\n    var ConfigurationOptionsUtil = (function () {\n        function ConfigurationOptionsUtil() {\n        }\n        /**\n         * Ensure configuration options make sense\n         */\n        ConfigurationOptionsUtil.validateConfigurationOptions = function (options) {\n            function defaultOnError(err) {\n                if (err.errorCode === 'load') {\n                    console.error('Loading \"' + err.moduleId + '\" failed');\n                    console.error('Detail: ', err.detail);\n                    if (err.detail && err.detail.stack) {\n                        console.error(err.detail.stack);\n                    }\n                    console.error('Here are the modules that depend on it:');\n                    console.error(err.neededBy);\n                    return;\n                }\n                if (err.errorCode === 'factory') {\n                    console.error('The factory method of \"' + err.moduleId + '\" has thrown an exception');\n                    console.error(err.detail);\n                    if (err.detail && err.detail.stack) {\n                        console.error(err.detail.stack);\n                    }\n                    return;\n                }\n            }\n            options = options || {};\n            if (typeof options.baseUrl !== 'string') {\n                options.baseUrl = '';\n            }\n            if (typeof options.isBuild !== 'boolean') {\n                options.isBuild = false;\n            }\n            if (typeof options.paths !== 'object') {\n                options.paths = {};\n            }\n            if (typeof options.bundles !== 'object') {\n                options.bundles = [];\n            }\n            if (typeof options.shim !== 'object') {\n                options.shim = {};\n            }\n            if (typeof options.config !== 'object') {\n                options.config = {};\n            }\n            if (typeof options.catchError === 'undefined') {\n                // Catch errors by default in web workers, do not catch errors by default in other contexts\n                options.catchError = isWebWorker;\n            }\n            if (typeof options.urlArgs !== 'string') {\n                options.urlArgs = '';\n            }\n            if (typeof options.onError !== 'function') {\n                options.onError = defaultOnError;\n            }\n            if (typeof options.ignoreDuplicateModules !== 'object' || !Utilities.isArray(options.ignoreDuplicateModules)) {\n                options.ignoreDuplicateModules = [];\n            }\n            if (options.baseUrl.length > 0) {\n                if (!Utilities.endsWith(options.baseUrl, '/')) {\n                    options.baseUrl += '/';\n                }\n            }\n            if (!Array.isArray(options.nodeModules)) {\n                options.nodeModules = [];\n            }\n            return options;\n        };\n        ConfigurationOptionsUtil.mergeConfigurationOptions = function (overwrite, base) {\n            if (overwrite === void 0) { overwrite = null; }\n            if (base === void 0) { base = null; }\n            var result = Utilities.recursiveClone(base || {});\n            // Merge known properties and overwrite the unknown ones\n            Utilities.forEachProperty(overwrite, function (key, value) {\n                if (key === 'bundles' && typeof result.bundles !== 'undefined') {\n                    if (Utilities.isArray(value)) {\n                        // Compatibility style\n                        result.bundles = result.bundles.concat(value);\n                    }\n                    else {\n                        // AMD API style\n                        Utilities.forEachProperty(value, function (key, value) {\n                            var bundleConfiguration = {\n                                location: key,\n                                modules: value\n                            };\n                            result.bundles.push(bundleConfiguration);\n                        });\n                    }\n                }\n                else if (key === 'ignoreDuplicateModules' && typeof result.ignoreDuplicateModules !== 'undefined') {\n                    result.ignoreDuplicateModules = result.ignoreDuplicateModules.concat(value);\n                }\n                else if (key === 'paths' && typeof result.paths !== 'undefined') {\n                    Utilities.forEachProperty(value, function (key2, value2) { return result.paths[key2] = value2; });\n                }\n                else if (key === 'shim' && typeof result.shim !== 'undefined') {\n                    Utilities.forEachProperty(value, function (key2, value2) { return result.shim[key2] = value2; });\n                }\n                else if (key === 'config' && typeof result.config !== 'undefined') {\n                    Utilities.forEachProperty(value, function (key2, value2) { return result.config[key2] = value2; });\n                }\n                else {\n                    result[key] = Utilities.recursiveClone(value);\n                }\n            });\n            return ConfigurationOptionsUtil.validateConfigurationOptions(result);\n        };\n        return ConfigurationOptionsUtil;\n    }());\n    AMDLoader.ConfigurationOptionsUtil = ConfigurationOptionsUtil;\n    var Configuration = (function () {\n        function Configuration(options) {\n            this.options = ConfigurationOptionsUtil.mergeConfigurationOptions(options);\n            this._createIgnoreDuplicateModulesMap();\n            this._createSortedPathsRules();\n            this._createShimModules();\n            this._createOverwriteModuleIdToPath();\n            if (this.options.baseUrl === '') {\n                if (isNode && this.options.nodeRequire && this.options.nodeRequire.main && this.options.nodeRequire.main.filename) {\n                    var nodeMain = this.options.nodeRequire.main.filename;\n                    var dirnameIndex = Math.max(nodeMain.lastIndexOf('/'), nodeMain.lastIndexOf('\\\\'));\n                    this.options.baseUrl = nodeMain.substring(0, dirnameIndex + 1);\n                }\n                if (isNode && this.options.nodeMain) {\n                    var nodeMain = this.options.nodeMain;\n                    var dirnameIndex = Math.max(nodeMain.lastIndexOf('/'), nodeMain.lastIndexOf('\\\\'));\n                    this.options.baseUrl = nodeMain.substring(0, dirnameIndex + 1);\n                }\n            }\n        }\n        Configuration.prototype._createOverwriteModuleIdToPath = function () {\n            this.overwriteModuleIdToPath = {};\n            for (var i = 0; i < this.options.bundles.length; i++) {\n                var bundle = this.options.bundles[i];\n                var location = bundle.location;\n                if (bundle.modules) {\n                    for (var j = 0; j < bundle.modules.length; j++) {\n                        this.overwriteModuleIdToPath[bundle.modules[j]] = location;\n                    }\n                }\n            }\n        };\n        Configuration.prototype._createIgnoreDuplicateModulesMap = function () {\n            // Build a map out of the ignoreDuplicateModules array\n            this.ignoreDuplicateModulesMap = {};\n            for (var i = 0; i < this.options.ignoreDuplicateModules.length; i++) {\n                this.ignoreDuplicateModulesMap[this.options.ignoreDuplicateModules[i]] = true;\n            }\n        };\n        Configuration.prototype._createSortedPathsRules = function () {\n            var _this = this;\n            // Create an array our of the paths rules, sorted descending by length to\n            // result in a more specific -> less specific order\n            this.sortedPathsRules = [];\n            Utilities.forEachProperty(this.options.paths, function (from, to) {\n                if (!Utilities.isArray(to)) {\n                    _this.sortedPathsRules.push({\n                        from: from,\n                        to: [to]\n                    });\n                }\n                else {\n                    _this.sortedPathsRules.push({\n                        from: from,\n                        to: to\n                    });\n                }\n            });\n            this.sortedPathsRules.sort(function (a, b) {\n                return b.from.length - a.from.length;\n            });\n        };\n        Configuration.prototype._ensureShimModule1 = function (path, shimMD) {\n            // Ensure dependencies are also shimmed\n            for (var i = 0; i < shimMD.length; i++) {\n                var dependencyId = shimMD[i];\n                if (!this.shimModules.hasOwnProperty(dependencyId)) {\n                    this._ensureShimModule1(dependencyId, []);\n                }\n            }\n            this.shimModules[path] = {\n                stack: null,\n                dependencies: shimMD,\n                callback: null\n            };\n            if (this.options.isBuild) {\n                this.shimModulesStr[path] = 'null';\n            }\n        };\n        Configuration.prototype._ensureShimModule2 = function (path, shimMD) {\n            this.shimModules[path] = {\n                stack: null,\n                dependencies: shimMD.deps || [],\n                callback: function () {\n                    var depsValues = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        depsValues[_i - 0] = arguments[_i];\n                    }\n                    if (typeof shimMD.init === 'function') {\n                        var initReturnValue = shimMD.init.apply(global, depsValues);\n                        if (typeof initReturnValue !== 'undefined') {\n                            return initReturnValue;\n                        }\n                    }\n                    if (typeof shimMD.exports === 'function') {\n                        return shimMD.exports.apply(global, depsValues);\n                    }\n                    if (typeof shimMD.exports === 'string') {\n                        var pieces = shimMD.exports.split('.');\n                        var obj = global;\n                        for (var i = 0; i < pieces.length; i++) {\n                            if (obj) {\n                                obj = obj[pieces[i]];\n                            }\n                        }\n                        return obj;\n                    }\n                    return shimMD.exports || {};\n                }\n            };\n            if (this.options.isBuild) {\n                if (typeof shimMD.init === 'function') {\n                    this.shimModulesStr[path] = shimMD.init.toString();\n                }\n                else if (typeof shimMD.exports === 'function') {\n                    this.shimModulesStr[path] = shimMD.exports.toString();\n                }\n                else if (typeof shimMD.exports === 'string') {\n                    this.shimModulesStr[path] = 'function() { return this.' + shimMD.exports + '; }';\n                }\n                else {\n                    this.shimModulesStr[path] = JSON.stringify(shimMD.exports);\n                }\n            }\n        };\n        Configuration.prototype._createShimModules = function () {\n            var _this = this;\n            this.shimModules = {};\n            this.shimModulesStr = {};\n            Utilities.forEachProperty(this.options.shim, function (path, shimMD) {\n                if (!shimMD) {\n                    return;\n                }\n                if (Utilities.isArray(shimMD)) {\n                    _this._ensureShimModule1(path, shimMD);\n                    return;\n                }\n                _this._ensureShimModule2(path, shimMD);\n            });\n        };\n        /**\n         * Clone current configuration and overwrite options selectively.\n         * @param options The selective options to overwrite with.\n         * @result A new configuration\n         */\n        Configuration.prototype.cloneAndMerge = function (options) {\n            return new Configuration(ConfigurationOptionsUtil.mergeConfigurationOptions(options, this.options));\n        };\n        /**\n         * Get current options bag. Useful for passing it forward to plugins.\n         */\n        Configuration.prototype.getOptionsLiteral = function () {\n            return this.options;\n        };\n        Configuration.prototype._applyPaths = function (moduleId) {\n            var pathRule;\n            for (var i = 0, len = this.sortedPathsRules.length; i < len; i++) {\n                pathRule = this.sortedPathsRules[i];\n                if (Utilities.startsWith(moduleId, pathRule.from)) {\n                    var result = [];\n                    for (var j = 0, lenJ = pathRule.to.length; j < lenJ; j++) {\n                        result.push(pathRule.to[j] + moduleId.substr(pathRule.from.length));\n                    }\n                    return result;\n                }\n            }\n            return [moduleId];\n        };\n        Configuration.prototype._addUrlArgsToUrl = function (url) {\n            if (Utilities.containsQueryString(url)) {\n                return url + '&' + this.options.urlArgs;\n            }\n            else {\n                return url + '?' + this.options.urlArgs;\n            }\n        };\n        Configuration.prototype._addUrlArgsIfNecessaryToUrl = function (url) {\n            if (this.options.urlArgs) {\n                return this._addUrlArgsToUrl(url);\n            }\n            return url;\n        };\n        Configuration.prototype._addUrlArgsIfNecessaryToUrls = function (urls) {\n            if (this.options.urlArgs) {\n                for (var i = 0, len = urls.length; i < len; i++) {\n                    urls[i] = this._addUrlArgsToUrl(urls[i]);\n                }\n            }\n            return urls;\n        };\n        /**\n         * Transform a module id to a location. Appends .js to module ids\n         */\n        Configuration.prototype.moduleIdToPaths = function (moduleId) {\n            if (this.isBuild() && this.options.nodeModules.indexOf(moduleId) >= 0) {\n                // This is a node module and we are at build time, drop it\n                return ['empty:'];\n            }\n            var result = moduleId;\n            if (this.overwriteModuleIdToPath.hasOwnProperty(result)) {\n                result = this.overwriteModuleIdToPath[result];\n            }\n            var results;\n            if (!Utilities.endsWith(result, '.js') && !Utilities.isAbsolutePath(result)) {\n                results = this._applyPaths(result);\n                for (var i = 0, len = results.length; i < len; i++) {\n                    if (this.isBuild() && results[i] === 'empty:') {\n                        continue;\n                    }\n                    if (!Utilities.isAbsolutePath(results[i])) {\n                        results[i] = this.options.baseUrl + results[i];\n                    }\n                    if (!Utilities.endsWith(results[i], '.js') && !Utilities.containsQueryString(results[i])) {\n                        results[i] = results[i] + '.js';\n                    }\n                }\n            }\n            else {\n                if (!Utilities.endsWith(result, '.js') && !Utilities.containsQueryString(result)) {\n                    result = result + '.js';\n                }\n                results = [result];\n            }\n            return this._addUrlArgsIfNecessaryToUrls(results);\n        };\n        /**\n         * Transform a module id or url to a location.\n         */\n        Configuration.prototype.requireToUrl = function (url) {\n            var result = url;\n            if (!Utilities.isAbsolutePath(result)) {\n                result = this._applyPaths(result)[0];\n                if (!Utilities.isAbsolutePath(result)) {\n                    result = this.options.baseUrl + result;\n                }\n            }\n            return this._addUrlArgsIfNecessaryToUrl(result);\n        };\n        /**\n         * Test if `moduleId` is shimmed.\n         */\n        Configuration.prototype.isShimmed = function (moduleId) {\n            return this.shimModules.hasOwnProperty(moduleId);\n        };\n        /**\n         * Flag to indicate if current execution is as part of a build.\n         */\n        Configuration.prototype.isBuild = function () {\n            return this.options.isBuild;\n        };\n        /**\n         * Get a normalized shim definition for `moduleId`.\n         */\n        Configuration.prototype.getShimmedModuleDefine = function (moduleId) {\n            return this.shimModules[moduleId];\n        };\n        Configuration.prototype.getShimmedModulesStr = function (moduleId) {\n            return this.shimModulesStr[moduleId];\n        };\n        /**\n         * Test if module `moduleId` is expected to be defined multiple times\n         */\n        Configuration.prototype.isDuplicateMessageIgnoredFor = function (moduleId) {\n            return this.ignoreDuplicateModulesMap.hasOwnProperty(moduleId);\n        };\n        /**\n         * Get the configuration settings for the provided module id\n         */\n        Configuration.prototype.getConfigForModule = function (moduleId) {\n            if (this.options.config) {\n                return this.options.config[moduleId];\n            }\n        };\n        /**\n         * Should errors be caught when executing module factories?\n         */\n        Configuration.prototype.shouldCatchError = function () {\n            return this.options.catchError;\n        };\n        /**\n         * Should statistics be recorded?\n         */\n        Configuration.prototype.shouldRecordStats = function () {\n            return this.options.recordStats;\n        };\n        /**\n         * Forward an error to the error handler.\n         */\n        Configuration.prototype.onError = function (err) {\n            this.options.onError(err);\n        };\n        return Configuration;\n    }());\n    AMDLoader.Configuration = Configuration;\n    // ------------------------------------------------------------------------\n    // ModuleIdResolver\n    var ModuleIdResolver = (function () {\n        function ModuleIdResolver(config, fromModuleId) {\n            this._config = config;\n            var lastSlash = fromModuleId.lastIndexOf('/');\n            if (lastSlash !== -1) {\n                this.fromModulePath = fromModuleId.substr(0, lastSlash + 1);\n            }\n            else {\n                this.fromModulePath = '';\n            }\n        }\n        ModuleIdResolver.prototype.isBuild = function () {\n            return this._config.isBuild();\n        };\n        /**\n         * Normalize 'a/../name' to 'name', etc.\n         */\n        ModuleIdResolver._normalizeModuleId = function (moduleId) {\n            var r = moduleId, pattern;\n            // replace /./ => /\n            pattern = /\\/\\.\\//;\n            while (pattern.test(r)) {\n                r = r.replace(pattern, '/');\n            }\n            // replace ^./ => nothing\n            r = r.replace(/^\\.\\//g, '');\n            // replace /aa/../ => / (BUT IGNORE /../../)\n            pattern = /\\/(([^\\/])|([^\\/][^\\/\\.])|([^\\/\\.][^\\/])|([^\\/][^\\/][^\\/]+))\\/\\.\\.\\//;\n            while (pattern.test(r)) {\n                r = r.replace(pattern, '/');\n            }\n            // replace ^aa/../ => nothing (BUT IGNORE ../../)\n            r = r.replace(/^(([^\\/])|([^\\/][^\\/\\.])|([^\\/\\.][^\\/])|([^\\/][^\\/][^\\/]+))\\/\\.\\.\\//, '');\n            return r;\n        };\n        /**\n         * Resolve relative module ids\n         */\n        ModuleIdResolver.prototype.resolveModule = function (moduleId) {\n            var result = moduleId;\n            if (!Utilities.isAbsolutePath(result)) {\n                if (Utilities.startsWith(result, './') || Utilities.startsWith(result, '../')) {\n                    result = ModuleIdResolver._normalizeModuleId(this.fromModulePath + result);\n                }\n            }\n            return result;\n        };\n        /**\n         * Transform a module id to a location. Appends .js to module ids\n         */\n        ModuleIdResolver.prototype.moduleIdToPaths = function (moduleId) {\n            var r = this._config.moduleIdToPaths(moduleId);\n            if (isNode && moduleId.indexOf('/') === -1) {\n                r.push('node|' + this.fromModulePath + '|' + moduleId);\n            }\n            return r;\n        };\n        /**\n         * Transform a module id or url to a location.\n         */\n        ModuleIdResolver.prototype.requireToUrl = function (url) {\n            return this._config.requireToUrl(url);\n        };\n        /**\n         * Should errors be caught when executing module factories?\n         */\n        ModuleIdResolver.prototype.shouldCatchError = function () {\n            return this._config.shouldCatchError();\n        };\n        /**\n         * Forward an error to the error handler.\n         */\n        ModuleIdResolver.prototype.onError = function (err) {\n            this._config.onError(err);\n        };\n        return ModuleIdResolver;\n    }());\n    AMDLoader.ModuleIdResolver = ModuleIdResolver;\n    // ------------------------------------------------------------------------\n    // Module\n    var Module = (function () {\n        function Module(id, dependencies, callback, errorback, recorder, moduleIdResolver, config, defineCallStack) {\n            if (defineCallStack === void 0) { defineCallStack = null; }\n            this._id = id;\n            this._dependencies = dependencies;\n            this._dependenciesValues = [];\n            this._callback = callback;\n            this._errorback = errorback;\n            this._recorder = recorder;\n            this._moduleIdResolver = moduleIdResolver;\n            this._exports = {};\n            this._exportsPassedIn = false;\n            this._config = config;\n            this._defineCallStack = defineCallStack;\n            this._digestDependencies();\n            if (this._unresolvedDependenciesCount === 0) {\n                this._complete();\n            }\n        }\n        Module.prototype._digestDependencies = function () {\n            var _this = this;\n            // Exact count of dependencies\n            this._unresolvedDependenciesCount = this._dependencies.length;\n            // Send on to the manager only a subset of dependencies\n            // For example, 'exports' and 'module' can be fulfilled locally\n            this._normalizedDependencies = [];\n            this._managerDependencies = [];\n            this._managerDependenciesMap = {};\n            var i, len, d;\n            for (i = 0, len = this._dependencies.length; i < len; i++) {\n                d = this._dependencies[i];\n                if (!d) {\n                    // Most likely, undefined sneaked in to the dependency array\n                    // Also, IE8 interprets ['a', 'b',] as ['a', 'b', undefined]\n                    console.warn('Please check module ' + this._id + ', the dependency list looks broken');\n                    this._normalizedDependencies[i] = d;\n                    this._dependenciesValues[i] = null;\n                    this._unresolvedDependenciesCount--;\n                    continue;\n                }\n                if (d === 'exports') {\n                    // Fulfill 'exports' locally and remember that it was passed in\n                    // Later on, we will ignore the return value of the factory method\n                    this._exportsPassedIn = true;\n                    this._normalizedDependencies[i] = d;\n                    this._dependenciesValues[i] = this._exports;\n                    this._unresolvedDependenciesCount--;\n                }\n                else if (d === 'module') {\n                    // Fulfill 'module' locally\n                    this._normalizedDependencies[i] = d;\n                    this._dependenciesValues[i] = {\n                        id: this._id,\n                        config: function () { return _this._config; }\n                    };\n                    this._unresolvedDependenciesCount--;\n                }\n                else if (d === 'require') {\n                    // Request 'requre' from the manager\n                    this._normalizedDependencies[i] = d;\n                    this.addManagerDependency(d, i);\n                }\n                else {\n                    // Normalize dependency and then request it from the manager\n                    var bangIndex = d.indexOf('!');\n                    if (bangIndex >= 0) {\n                        var pluginId = d.substring(0, bangIndex);\n                        var pluginParam = d.substring(bangIndex + 1, d.length);\n                        d = this._moduleIdResolver.resolveModule(pluginId) + '!' + pluginParam;\n                    }\n                    else {\n                        d = this._moduleIdResolver.resolveModule(d);\n                    }\n                    this._normalizedDependencies[i] = d;\n                    this.addManagerDependency(d, i);\n                }\n            }\n        };\n        Module.prototype.addManagerDependency = function (dependency, index) {\n            if (this._managerDependenciesMap.hasOwnProperty(dependency)) {\n                throw new Error('Module ' + this._id + ' contains multiple times a dependency to ' + dependency);\n            }\n            this._managerDependencies.push(dependency);\n            this._managerDependenciesMap[dependency] = index;\n        };\n        /**\n         * Called by the module manager because plugin dependencies can not\n         * be normalized statically, the part after '!' can only be normalized\n         * once the plugin has loaded and its normalize logic is plugged in.\n         */\n        Module.prototype.renameDependency = function (oldDependencyId, newDependencyId) {\n            if (!this._managerDependenciesMap.hasOwnProperty(oldDependencyId)) {\n                throw new Error('Loader: Cannot rename an unknown dependency!');\n            }\n            var index = this._managerDependenciesMap[oldDependencyId];\n            delete this._managerDependenciesMap[oldDependencyId];\n            this._managerDependenciesMap[newDependencyId] = index;\n            this._normalizedDependencies[index] = newDependencyId;\n        };\n        /**\n         * Get module's id\n         */\n        Module.prototype.getId = function () {\n            return this._id;\n        };\n        /**\n         * Get the module id resolver associated with this module\n         */\n        Module.prototype.getModuleIdResolver = function () {\n            return this._moduleIdResolver;\n        };\n        Module.prototype.isExportsPassedIn = function () {\n            return this._exportsPassedIn;\n        };\n        Module.prototype.getExports = function () {\n            return this._exports;\n        };\n        /**\n         * Get the initial dependencies (resolved).\n         * Does not account for any renames\n         */\n        Module.prototype.getDependencies = function () {\n            return this._managerDependencies;\n        };\n        Module.prototype.getNormalizedDependencies = function () {\n            return this._normalizedDependencies;\n        };\n        Module.prototype.getDefineCallStack = function () {\n            return this._defineCallStack;\n        };\n        Module.prototype._invokeFactory = function () {\n            if (this._moduleIdResolver.isBuild() && !Utilities.isAnonymousModule(this._id)) {\n                return {\n                    returnedValue: null,\n                    producedError: null\n                };\n            }\n            var producedError = null, returnedValue = null;\n            if (this._moduleIdResolver.shouldCatchError()) {\n                try {\n                    returnedValue = this._callback.apply(global, this._dependenciesValues);\n                }\n                catch (e) {\n                    producedError = e;\n                }\n                finally {\n                }\n            }\n            else {\n                returnedValue = this._callback.apply(global, this._dependenciesValues);\n            }\n            return {\n                returnedValue: returnedValue,\n                producedError: producedError\n            };\n        };\n        Module.prototype._complete = function () {\n            var producedError = null;\n            if (this._callback) {\n                if (typeof this._callback === 'function') {\n                    this._recorder.record(LoaderEventType.BeginInvokeFactory, this._id);\n                    var r = this._invokeFactory();\n                    producedError = r.producedError;\n                    this._recorder.record(LoaderEventType.EndInvokeFactory, this._id);\n                    if (!producedError && typeof r.returnedValue !== 'undefined' && (!this._exportsPassedIn || Utilities.isEmpty(this._exports))) {\n                        this._exports = r.returnedValue;\n                    }\n                }\n                else {\n                    this._exports = this._callback;\n                }\n            }\n            if (producedError) {\n                this.getModuleIdResolver().onError({\n                    errorCode: 'factory',\n                    moduleId: this._id,\n                    detail: producedError\n                });\n            }\n        };\n        /**\n         * Release references used while resolving module\n         */\n        Module.prototype.cleanUp = function () {\n            if (this._moduleIdResolver && !this._moduleIdResolver.isBuild()) {\n                this._normalizedDependencies = null;\n                this._moduleIdResolver = null;\n            }\n            this._dependencies = null;\n            this._dependenciesValues = null;\n            this._callback = null;\n            this._managerDependencies = null;\n            this._managerDependenciesMap = null;\n        };\n        /**\n         * One of the direct dependencies or a transitive dependency has failed to load.\n         */\n        Module.prototype.onDependencyError = function (err) {\n            if (this._errorback) {\n                this._errorback(err);\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Resolve a dependency with a value.\n         */\n        Module.prototype.resolveDependency = function (id, value) {\n            if (!this._managerDependenciesMap.hasOwnProperty(id)) {\n                throw new Error('Cannot resolve a dependency I do not have!');\n            }\n            this._dependenciesValues[this._managerDependenciesMap[id]] = value;\n            // Prevent resolving the same dependency twice\n            delete this._managerDependenciesMap[id];\n            this._unresolvedDependenciesCount--;\n            if (this._unresolvedDependenciesCount === 0) {\n                this._complete();\n            }\n        };\n        /**\n         * Is the current module complete?\n         */\n        Module.prototype.isComplete = function () {\n            return this._unresolvedDependenciesCount === 0;\n        };\n        return Module;\n    }());\n    AMDLoader.Module = Module;\n    // ------------------------------------------------------------------------\n    // LoaderEvent\n    (function (LoaderEventType) {\n        LoaderEventType[LoaderEventType[\"LoaderAvailable\"] = 1] = \"LoaderAvailable\";\n        LoaderEventType[LoaderEventType[\"BeginLoadingScript\"] = 10] = \"BeginLoadingScript\";\n        LoaderEventType[LoaderEventType[\"EndLoadingScriptOK\"] = 11] = \"EndLoadingScriptOK\";\n        LoaderEventType[LoaderEventType[\"EndLoadingScriptError\"] = 12] = \"EndLoadingScriptError\";\n        LoaderEventType[LoaderEventType[\"BeginInvokeFactory\"] = 21] = \"BeginInvokeFactory\";\n        LoaderEventType[LoaderEventType[\"EndInvokeFactory\"] = 22] = \"EndInvokeFactory\";\n        LoaderEventType[LoaderEventType[\"NodeBeginEvaluatingScript\"] = 31] = \"NodeBeginEvaluatingScript\";\n        LoaderEventType[LoaderEventType[\"NodeEndEvaluatingScript\"] = 32] = \"NodeEndEvaluatingScript\";\n        LoaderEventType[LoaderEventType[\"NodeBeginNativeRequire\"] = 33] = \"NodeBeginNativeRequire\";\n        LoaderEventType[LoaderEventType[\"NodeEndNativeRequire\"] = 34] = \"NodeEndNativeRequire\";\n    })(AMDLoader.LoaderEventType || (AMDLoader.LoaderEventType = {}));\n    var LoaderEventType = AMDLoader.LoaderEventType;\n    function getHighPerformanceTimestamp() {\n        return (hasPerformanceNow ? global.performance.now() : Date.now());\n    }\n    var LoaderEvent = (function () {\n        function LoaderEvent(type, detail, timestamp) {\n            this.type = type;\n            this.detail = detail;\n            this.timestamp = timestamp;\n        }\n        return LoaderEvent;\n    }());\n    AMDLoader.LoaderEvent = LoaderEvent;\n    var LoaderEventRecorder = (function () {\n        function LoaderEventRecorder(loaderAvailableTimestamp) {\n            this._events = [new LoaderEvent(LoaderEventType.LoaderAvailable, '', loaderAvailableTimestamp)];\n        }\n        LoaderEventRecorder.prototype.record = function (type, detail) {\n            this._events.push(new LoaderEvent(type, detail, getHighPerformanceTimestamp()));\n        };\n        LoaderEventRecorder.prototype.getEvents = function () {\n            return this._events;\n        };\n        return LoaderEventRecorder;\n    }());\n    AMDLoader.LoaderEventRecorder = LoaderEventRecorder;\n    var NullLoaderEventRecorder = (function () {\n        function NullLoaderEventRecorder() {\n        }\n        NullLoaderEventRecorder.prototype.record = function (type, detail) {\n            // Nothing to do\n        };\n        NullLoaderEventRecorder.prototype.getEvents = function () {\n            return [];\n        };\n        NullLoaderEventRecorder.INSTANCE = new NullLoaderEventRecorder();\n        return NullLoaderEventRecorder;\n    }());\n    AMDLoader.NullLoaderEventRecorder = NullLoaderEventRecorder;\n    var ModuleManager = (function () {\n        function ModuleManager(scriptLoader) {\n            this._recorder = null;\n            this._config = new Configuration();\n            this._scriptLoader = scriptLoader;\n            this._modules = {};\n            this._knownModules = {};\n            this._inverseDependencies = {};\n            this._dependencies = {};\n            this._inversePluginDependencies = {};\n            this._queuedDefineCalls = [];\n            this._loadingScriptsCount = 0;\n            this._resolvedScriptPaths = {};\n        }\n        ModuleManager._findRelevantLocationInStack = function (needle, stack) {\n            var normalize = function (str) { return str.replace(/\\\\/g, '/'); };\n            var normalizedPath = normalize(needle);\n            var stackPieces = stack.split(/\\n/);\n            for (var i = 0; i < stackPieces.length; i++) {\n                var m = stackPieces[i].match(/(.*):(\\d+):(\\d+)\\)?$/);\n                if (m) {\n                    var stackPath = m[1];\n                    var stackLine = m[2];\n                    var stackColumn = m[3];\n                    var trimPathOffset = Math.max(stackPath.lastIndexOf(' ') + 1, stackPath.lastIndexOf('(') + 1);\n                    stackPath = stackPath.substr(trimPathOffset);\n                    stackPath = normalize(stackPath);\n                    if (stackPath === normalizedPath) {\n                        var r = {\n                            line: parseInt(stackLine, 10),\n                            col: parseInt(stackColumn, 10)\n                        };\n                        if (r.line === 1) {\n                            r.col -= '(function (require, define, __filename, __dirname) { '.length;\n                        }\n                        return r;\n                    }\n                }\n            }\n            throw new Error('Could not correlate define call site for needle ' + needle);\n        };\n        ModuleManager.prototype.getBuildInfo = function () {\n            var _this = this;\n            if (!this._config.isBuild()) {\n                return null;\n            }\n            return Object.keys(this._modules).map(function (moduleId) {\n                var m = _this._modules[moduleId];\n                var location = _this._resolvedScriptPaths[moduleId] || null;\n                var defineStack = m.getDefineCallStack();\n                return {\n                    id: moduleId,\n                    path: location,\n                    defineLocation: (location && defineStack ? ModuleManager._findRelevantLocationInStack(location, defineStack) : null),\n                    dependencies: m.getNormalizedDependencies(),\n                    shim: (_this._config.isShimmed(moduleId) ? _this._config.getShimmedModulesStr(moduleId) : null),\n                    exports: m.getExports()\n                };\n            });\n        };\n        ModuleManager.prototype.getRecorder = function () {\n            if (!this._recorder) {\n                if (this._config.shouldRecordStats()) {\n                    this._recorder = new LoaderEventRecorder(loaderAvailableTimestamp);\n                }\n                else {\n                    this._recorder = NullLoaderEventRecorder.INSTANCE;\n                }\n            }\n            return this._recorder;\n        };\n        ModuleManager.prototype.getLoaderEvents = function () {\n            return this.getRecorder().getEvents();\n        };\n        /**\n         * Defines a module.\n         * @param id @see defineModule\n         * @param dependencies @see defineModule\n         * @param callback @see defineModule\n         */\n        ModuleManager.prototype.enqueueDefineModule = function (id, dependencies, callback) {\n            if (this._loadingScriptsCount === 0) {\n                // There are no scripts currently loading, so no load event will be fired, so the queue will not be consumed\n                this.defineModule(id, dependencies, callback, null, null);\n            }\n            else {\n                this._queuedDefineCalls.push({\n                    id: id,\n                    stack: null,\n                    dependencies: dependencies,\n                    callback: callback\n                });\n            }\n        };\n        /**\n         * Defines an anonymous module (without an id). Its name will be resolved as we receive a callback from the scriptLoader.\n         * @param dependecies @see defineModule\n         * @param callback @see defineModule\n         */\n        ModuleManager.prototype.enqueueDefineAnonymousModule = function (dependencies, callback) {\n            var stack = null;\n            if (this._config.isBuild()) {\n                stack = (new Error('StackLocation')).stack;\n            }\n            this._queuedDefineCalls.push({\n                id: null,\n                stack: stack,\n                dependencies: dependencies,\n                callback: callback\n            });\n        };\n        /**\n         * Creates a module and stores it in _modules. The manager will immediately begin resolving its dependencies.\n         * @param id An unique and absolute id of the module. This must not collide with another module's id\n         * @param dependencies An array with the dependencies of the module. Special keys are: \"require\", \"exports\" and \"module\"\n         * @param callback if callback is a function, it will be called with the resolved dependencies. if callback is an object, it will be considered as the exports of the module.\n         */\n        ModuleManager.prototype.defineModule = function (id, dependencies, callback, errorback, stack, moduleIdResolver) {\n            if (moduleIdResolver === void 0) { moduleIdResolver = new ModuleIdResolver(this._config, id); }\n            if (this._modules.hasOwnProperty(id)) {\n                if (!this._config.isDuplicateMessageIgnoredFor(id)) {\n                    console.warn('Duplicate definition of module \\'' + id + '\\'');\n                }\n                // Super important! Completely ignore duplicate module definition\n                return;\n            }\n            var moduleConfig = this._config.getConfigForModule(id);\n            var m = new Module(id, dependencies, callback, errorback, this.getRecorder(), moduleIdResolver, moduleConfig, stack);\n            this._modules[id] = m;\n            // Resolving of dependencies is immediate (not in a timeout). If there's a need to support a packer that concatenates in an\n            // unordered manner, in order to finish processing the file, execute the following method in a timeout\n            this._resolve(m);\n        };\n        ModuleManager.prototype._relativeRequire = function (moduleIdResolver, dependencies, callback, errorback) {\n            if (typeof dependencies === 'string') {\n                return this.synchronousRequire(dependencies, moduleIdResolver);\n            }\n            this.defineModule(Utilities.generateAnonymousModule(), dependencies, callback, errorback, null, moduleIdResolver);\n        };\n        /**\n         * Require synchronously a module by its absolute id. If the module is not loaded, an exception will be thrown.\n         * @param id The unique and absolute id of the required module\n         * @return The exports of module 'id'\n         */\n        ModuleManager.prototype.synchronousRequire = function (id, moduleIdResolver) {\n            if (moduleIdResolver === void 0) { moduleIdResolver = new ModuleIdResolver(this._config, id); }\n            var moduleId = moduleIdResolver.resolveModule(id);\n            var bangIndex = moduleId.indexOf('!');\n            if (bangIndex >= 0) {\n                // This is a synchronous require for a plugin dependency, so be sure to normalize the pluginParam (the piece after '!')\n                var pluginId = moduleId.substring(0, bangIndex), pluginParam = moduleId.substring(bangIndex + 1, moduleId.length), plugin = {};\n                if (this._modules.hasOwnProperty(pluginId)) {\n                    plugin = this._modules[pluginId];\n                }\n                // Helper to normalize the part which comes after '!'\n                var normalize = function (_arg) {\n                    return moduleIdResolver.resolveModule(_arg);\n                };\n                if (typeof plugin.normalize === 'function') {\n                    pluginParam = plugin.normalize(pluginParam, normalize);\n                }\n                else {\n                    pluginParam = normalize(pluginParam);\n                }\n                moduleId = pluginId + '!' + pluginParam;\n            }\n            if (!this._modules.hasOwnProperty(moduleId)) {\n                throw new Error('Check dependency list! Synchronous require cannot resolve module \\'' + moduleId + '\\'. This is the first mention of this module!');\n            }\n            var m = this._modules[moduleId];\n            if (!m.isComplete()) {\n                throw new Error('Check dependency list! Synchronous require cannot resolve module \\'' + moduleId + '\\'. This module has not been resolved completely yet.');\n            }\n            return m.getExports();\n        };\n        ModuleManager.prototype.configure = function (params, shouldOverwrite) {\n            var oldShouldRecordStats = this._config.shouldRecordStats();\n            if (shouldOverwrite) {\n                this._config = new Configuration(params);\n            }\n            else {\n                this._config = this._config.cloneAndMerge(params);\n            }\n            if (this._config.shouldRecordStats() && !oldShouldRecordStats) {\n                this._recorder = null;\n            }\n        };\n        ModuleManager.prototype.getConfigurationOptions = function () {\n            return this._config.getOptionsLiteral();\n        };\n        /**\n         * Callback from the scriptLoader when a module has been loaded.\n         * This means its code is available and has been executed.\n         */\n        ModuleManager.prototype._onLoad = function (id) {\n            var defineCall;\n            this._loadingScriptsCount--;\n            if (this._config.isShimmed(id)) {\n                // Do not consume queue, might end up consuming a module that is later expected\n                // If a shimmed module has loaded, create a define call for it\n                defineCall = this._config.getShimmedModuleDefine(id);\n                this.defineModule(id, defineCall.dependencies, defineCall.callback, null, defineCall.stack);\n            }\n            else {\n                if (this._queuedDefineCalls.length === 0) {\n                    // Loaded a file and it didn't call `define`\n                    this._loadingScriptsCount++;\n                    this._onLoadError(id, new Error('No define call received from module ' + id + '.'));\n                }\n                else {\n                    // Consume queue until first anonymous define call\n                    // or until current id is found in the queue\n                    while (this._queuedDefineCalls.length > 0) {\n                        defineCall = this._queuedDefineCalls.shift();\n                        if (defineCall.id === id || defineCall.id === null) {\n                            // Hit an anonymous define call or its own define call\n                            defineCall.id = id;\n                            this.defineModule(defineCall.id, defineCall.dependencies, defineCall.callback, null, defineCall.stack);\n                            break;\n                        }\n                        else {\n                            // Hit other named define calls\n                            this.defineModule(defineCall.id, defineCall.dependencies, defineCall.callback, null, defineCall.stack);\n                        }\n                    }\n                }\n            }\n            if (this._loadingScriptsCount === 0) {\n                // No more on loads will be triggered, so make sure queue is empty\n                while (this._queuedDefineCalls.length > 0) {\n                    defineCall = this._queuedDefineCalls.shift();\n                    if (defineCall.id === null) {\n                        console.warn('Found an unmatched anonymous define call in the define queue. Ignoring it!');\n                        console.warn(defineCall.callback);\n                    }\n                    else {\n                        // Hit other named define calls\n                        this.defineModule(defineCall.id, defineCall.dependencies, defineCall.callback, null, defineCall.stack);\n                    }\n                }\n            }\n        };\n        /**\n         * Callback from the scriptLoader when a module hasn't been loaded.\n         * This means that the script was not found (e.g. 404) or there was an error in the script.\n         */\n        ModuleManager.prototype._onLoadError = function (id, err) {\n            this._loadingScriptsCount--;\n            var error = {\n                errorCode: 'load',\n                moduleId: id,\n                neededBy: (this._inverseDependencies[id] ? this._inverseDependencies[id].slice(0) : []),\n                detail: err\n            };\n            // Find any 'local' error handlers, walk the entire chain of inverse dependencies if necessary.\n            var seenModuleId = {}, queueElement, someoneNotified = false, queue = [];\n            queue.push(id);\n            seenModuleId[id] = true;\n            while (queue.length > 0) {\n                queueElement = queue.shift();\n                if (this._modules[queueElement]) {\n                    someoneNotified = this._modules[queueElement].onDependencyError(error) || someoneNotified;\n                }\n                if (this._inverseDependencies[queueElement]) {\n                    for (var i = 0, len = this._inverseDependencies[queueElement].length; i < len; i++) {\n                        if (!seenModuleId.hasOwnProperty(this._inverseDependencies[queueElement][i])) {\n                            queue.push(this._inverseDependencies[queueElement][i]);\n                            seenModuleId[this._inverseDependencies[queueElement][i]] = true;\n                        }\n                    }\n                }\n            }\n            if (!someoneNotified) {\n                this._config.onError(error);\n            }\n        };\n        /**\n         * Module id has been loaded completely, its exports are available.\n         * @param id module's id\n         * @param exports module's exports\n         */\n        ModuleManager.prototype._onModuleComplete = function (id, exports) {\n            var i, len, inverseDependencyId, inverseDependency;\n            // Clean up module's dependencies since module is now complete\n            delete this._dependencies[id];\n            if (this._inverseDependencies.hasOwnProperty(id)) {\n                // Fetch and clear inverse dependencies\n                var inverseDependencies = this._inverseDependencies[id];\n                delete this._inverseDependencies[id];\n                // Resolve one inverse dependency at a time, always\n                // on the lookout for a completed module.\n                for (i = 0, len = inverseDependencies.length; i < len; i++) {\n                    inverseDependencyId = inverseDependencies[i];\n                    inverseDependency = this._modules[inverseDependencyId];\n                    inverseDependency.resolveDependency(id, exports);\n                    if (inverseDependency.isComplete()) {\n                        this._onModuleComplete(inverseDependencyId, inverseDependency.getExports());\n                    }\n                }\n            }\n            if (this._inversePluginDependencies.hasOwnProperty(id)) {\n                // This module is used as a plugin at least once\n                // Fetch and clear these inverse plugin dependencies\n                var inversePluginDependencies = this._inversePluginDependencies[id];\n                delete this._inversePluginDependencies[id];\n                // Resolve plugin dependencies one at a time\n                for (i = 0, len = inversePluginDependencies.length; i < len; i++) {\n                    var inversePluginDependencyId = inversePluginDependencies[i].moduleId;\n                    var inversePluginDependency = this._modules[inversePluginDependencyId];\n                    this._resolvePluginDependencySync(inversePluginDependencyId, inversePluginDependencies[i].dependencyId, exports);\n                    // Anonymous modules might already be gone at this point\n                    if (inversePluginDependency.isComplete()) {\n                        this._onModuleComplete(inversePluginDependencyId, inversePluginDependency.getExports());\n                    }\n                }\n            }\n            if (Utilities.isAnonymousModule(id)) {\n                // Clean up references to anonymous modules, to prevent memory leaks\n                delete this._modules[id];\n                delete this._dependencies[id];\n            }\n            else {\n                this._modules[id].cleanUp();\n            }\n        };\n        /**\n         * Walks (recursively) the dependencies of 'from' in search of 'to'.\n         * Returns true if there is such a path or false otherwise.\n         * @param from Module id to start at\n         * @param to Module id to look for\n         */\n        ModuleManager.prototype._hasDependencyPath = function (from, to) {\n            var i, len, inQueue = {}, queue = [], element, dependencies, dependency;\n            // Insert 'from' in queue\n            queue.push(from);\n            inQueue[from] = true;\n            while (queue.length > 0) {\n                // Pop first inserted element of queue\n                element = queue.shift();\n                if (this._dependencies.hasOwnProperty(element)) {\n                    dependencies = this._dependencies[element];\n                    // Walk the element's dependencies\n                    for (i = 0, len = dependencies.length; i < len; i++) {\n                        dependency = dependencies[i];\n                        if (dependency === to) {\n                            // There is a path to 'to'\n                            return true;\n                        }\n                        if (!inQueue.hasOwnProperty(dependency)) {\n                            // Insert 'dependency' in queue\n                            inQueue[dependency] = true;\n                            queue.push(dependency);\n                        }\n                    }\n                }\n            }\n            // There is no path to 'to'\n            return false;\n        };\n        /**\n         * Walks (recursively) the dependencies of 'from' in search of 'to'.\n         * Returns cycle as array.\n         * @param from Module id to start at\n         * @param to Module id to look for\n         */\n        ModuleManager.prototype._findCyclePath = function (from, to, depth) {\n            if (from === to || depth === 50) {\n                return [from];\n            }\n            if (!this._dependencies.hasOwnProperty(from)) {\n                return null;\n            }\n            var path, dependencies = this._dependencies[from];\n            // Walk the element's dependencies\n            for (var i = 0, len = dependencies.length; i < len; i++) {\n                path = this._findCyclePath(dependencies[i], to, depth + 1);\n                if (path !== null) {\n                    path.push(from);\n                    return path;\n                }\n            }\n            return null;\n        };\n        /**\n         * Create the local 'require' that is passed into modules\n         */\n        ModuleManager.prototype._createRequire = function (moduleIdResolver) {\n            var _this = this;\n            var result = (function (dependencies, callback, errorback) {\n                return _this._relativeRequire(moduleIdResolver, dependencies, callback, errorback);\n            });\n            result.toUrl = function (id) {\n                return moduleIdResolver.requireToUrl(moduleIdResolver.resolveModule(id));\n            };\n            result.getStats = function () {\n                return _this.getLoaderEvents();\n            };\n            result.__$__nodeRequire = global.nodeRequire;\n            return result;\n        };\n        /**\n         * Resolve a plugin dependency with the plugin loaded & complete\n         * @param moduleId The module that has this dependency\n         * @param dependencyId The semi-normalized dependency that appears in the module. e.g. 'vs/css!./mycssfile'. Only the plugin part (before !) is normalized\n         * @param plugin The plugin (what the plugin exports)\n         */\n        ModuleManager.prototype._resolvePluginDependencySync = function (moduleId, dependencyId, plugin) {\n            var _this = this;\n            var m = this._modules[moduleId], moduleIdResolver = m.getModuleIdResolver(), bangIndex = dependencyId.indexOf('!'), pluginId = dependencyId.substring(0, bangIndex), pluginParam = dependencyId.substring(bangIndex + 1, dependencyId.length);\n            // Helper to normalize the part which comes after '!'\n            var normalize = function (_arg) {\n                return moduleIdResolver.resolveModule(_arg);\n            };\n            if (typeof plugin.normalize === 'function') {\n                pluginParam = plugin.normalize(pluginParam, normalize);\n            }\n            else {\n                pluginParam = normalize(pluginParam);\n            }\n            if (!plugin.dynamic) {\n                // Now normalize the entire dependency\n                var oldDependencyId = dependencyId;\n                dependencyId = pluginId + '!' + pluginParam;\n                // Let the module know that the dependency has been normalized so it can update its internal state\n                m.renameDependency(oldDependencyId, dependencyId);\n                this._resolveDependency(moduleId, dependencyId, function (moduleId) {\n                    // Delegate the loading of the resource to the plugin\n                    var load = (function (value) {\n                        _this.defineModule(dependencyId, [], value, null, null);\n                    });\n                    load.error = function (err) {\n                        _this._config.onError({\n                            errorCode: 'load',\n                            moduleId: dependencyId,\n                            neededBy: (_this._inverseDependencies[dependencyId] ? _this._inverseDependencies[dependencyId].slice(0) : []),\n                            detail: err\n                        });\n                    };\n                    plugin.load(pluginParam, _this._createRequire(moduleIdResolver), load, _this._config.getOptionsLiteral());\n                });\n            }\n            else {\n                // This plugin is dynamic and does not want the loader to cache anything on its behalf\n                // Delegate the loading of the resource to the plugin\n                var load = (function (value) {\n                    m.resolveDependency(dependencyId, value);\n                    if (m.isComplete()) {\n                        _this._onModuleComplete(moduleId, m.getExports());\n                    }\n                });\n                load.error = function (err) {\n                    _this._config.onError({\n                        errorCode: 'load',\n                        moduleId: dependencyId,\n                        neededBy: [moduleId],\n                        detail: err\n                    });\n                };\n                plugin.load(pluginParam, this._createRequire(moduleIdResolver), load, this._config.getOptionsLiteral());\n            }\n        };\n        /**\n         * Resolve a plugin dependency with the plugin not loaded or not complete yet\n         * @param moduleId The module that has this dependency\n         * @param dependencyId The semi-normalized dependency that appears in the module. e.g. 'vs/css!./mycssfile'. Only the plugin part (before !) is normalized\n         */\n        ModuleManager.prototype._resolvePluginDependencyAsync = function (moduleId, dependencyId) {\n            var m = this._modules[moduleId], bangIndex = dependencyId.indexOf('!'), pluginId = dependencyId.substring(0, bangIndex);\n            // Record dependency for when the plugin gets loaded\n            this._inversePluginDependencies[pluginId] = this._inversePluginDependencies[pluginId] || [];\n            this._inversePluginDependencies[pluginId].push({\n                moduleId: moduleId,\n                dependencyId: dependencyId\n            });\n            if (!this._modules.hasOwnProperty(pluginId) && !this._knownModules.hasOwnProperty(pluginId)) {\n                // This is the first mention of module 'pluginId', so load it\n                this._knownModules[pluginId] = true;\n                this._loadModule(m.getModuleIdResolver(), pluginId);\n            }\n        };\n        /**\n         * Resolve a plugin dependency\n         * @param moduleId The module that has this dependency\n         * @param dependencyId The semi-normalized dependency that appears in the module. e.g. 'vs/css!./mycssfile'. Only the plugin part (before !) is normalized\n         */\n        ModuleManager.prototype._resolvePluginDependency = function (moduleId, dependencyId) {\n            var bangIndex = dependencyId.indexOf('!'), pluginId = dependencyId.substring(0, bangIndex);\n            if (this._modules.hasOwnProperty(pluginId) && this._modules[pluginId].isComplete()) {\n                // Plugin has already been loaded & resolved\n                this._resolvePluginDependencySync(moduleId, dependencyId, this._modules[pluginId].getExports());\n            }\n            else {\n                // Plugin is not loaded or not resolved\n                this._resolvePluginDependencyAsync(moduleId, dependencyId);\n            }\n        };\n        /**\n         * Resolve a module dependency to a shimmed module and delegate the loading to loadCallback.\n         * @param moduleId The module that has this dependency\n         * @param dependencyId The normalized dependency that appears in the module -- this module is shimmed\n         * @param loadCallback Callback that will be called to trigger the loading of 'dependencyId' if needed\n         */\n        ModuleManager.prototype._resolveShimmedDependency = function (moduleId, dependencyId, loadCallback) {\n            // If a shimmed module has dependencies, we must first load those dependencies\n            // and only when those are loaded we can load the shimmed module.\n            // To achieve this, we inject a module definition with those dependencies\n            // and from its factory method we really load the shimmed module.\n            var defineInfo = this._config.getShimmedModuleDefine(dependencyId);\n            if (defineInfo.dependencies.length > 0) {\n                this.defineModule(Utilities.generateAnonymousModule(), defineInfo.dependencies, function () { return loadCallback(dependencyId); }, null, null, new ModuleIdResolver(this._config, dependencyId));\n            }\n            else {\n                loadCallback(dependencyId);\n            }\n        };\n        /**\n         * Resolve a module dependency and delegate the loading to loadCallback\n         * @param moduleId The module that has this dependency\n         * @param dependencyId The normalized dependency that appears in the module\n         * @param loadCallback Callback that will be called to trigger the loading of 'dependencyId' if needed\n         */\n        ModuleManager.prototype._resolveDependency = function (moduleId, dependencyId, loadCallback) {\n            var m = this._modules[moduleId];\n            if (this._modules.hasOwnProperty(dependencyId) && this._modules[dependencyId].isComplete()) {\n                // Dependency has already been loaded & resolved\n                m.resolveDependency(dependencyId, this._modules[dependencyId].getExports());\n            }\n            else {\n                // Dependency is not loaded or not resolved\n                // Record dependency\n                this._dependencies[moduleId].push(dependencyId);\n                if (this._hasDependencyPath(dependencyId, moduleId)) {\n                    console.warn('There is a dependency cycle between \\'' + dependencyId + '\\' and \\'' + moduleId + '\\'. The cyclic path follows:');\n                    var cyclePath = this._findCyclePath(dependencyId, moduleId, 0);\n                    cyclePath.reverse();\n                    cyclePath.push(dependencyId);\n                    console.warn(cyclePath.join(' => \\n'));\n                    // Break the cycle\n                    var dependency = this._modules.hasOwnProperty(dependencyId) ? this._modules[dependencyId] : null;\n                    var dependencyValue;\n                    if (dependency && dependency.isExportsPassedIn()) {\n                        // If dependency uses 'exports', then resolve it with that object\n                        dependencyValue = dependency.getExports();\n                    }\n                    // Resolve dependency with undefined or with 'exports' object\n                    m.resolveDependency(dependencyId, dependencyValue);\n                }\n                else {\n                    // Since we are actually waiting for this dependency,\n                    // record inverse dependency\n                    this._inverseDependencies[dependencyId] = this._inverseDependencies[dependencyId] || [];\n                    this._inverseDependencies[dependencyId].push(moduleId);\n                    if (!this._modules.hasOwnProperty(dependencyId) && !this._knownModules.hasOwnProperty(dependencyId)) {\n                        // This is the first mention of module 'dependencyId', so load it\n                        // Mark this module as loaded so we don't hit this case again\n                        this._knownModules[dependencyId] = true;\n                        if (this._config.isShimmed(dependencyId)) {\n                            this._resolveShimmedDependency(moduleId, dependencyId, loadCallback);\n                        }\n                        else {\n                            loadCallback(dependencyId);\n                        }\n                    }\n                }\n            }\n        };\n        ModuleManager.prototype._loadModule = function (anyModuleIdResolver, moduleId) {\n            var _this = this;\n            this._loadingScriptsCount++;\n            var paths = anyModuleIdResolver.moduleIdToPaths(moduleId);\n            var lastPathIndex = -1;\n            var loadNextPath = function (err) {\n                lastPathIndex++;\n                if (lastPathIndex >= paths.length) {\n                    // No more paths to try\n                    _this._onLoadError(moduleId, err);\n                }\n                else {\n                    var currentPath = paths[lastPathIndex];\n                    var recorder = _this.getRecorder();\n                    if (_this._config.isBuild() && currentPath === 'empty:') {\n                        _this._resolvedScriptPaths[moduleId] = currentPath;\n                        _this.enqueueDefineModule(moduleId, [], null);\n                        _this._onLoad(moduleId);\n                        return;\n                    }\n                    recorder.record(LoaderEventType.BeginLoadingScript, currentPath);\n                    _this._scriptLoader.load(currentPath, function () {\n                        if (_this._config.isBuild()) {\n                            _this._resolvedScriptPaths[moduleId] = currentPath;\n                        }\n                        recorder.record(LoaderEventType.EndLoadingScriptOK, currentPath);\n                        _this._onLoad(moduleId);\n                    }, function (err) {\n                        recorder.record(LoaderEventType.EndLoadingScriptError, currentPath);\n                        loadNextPath(err);\n                    }, recorder);\n                }\n            };\n            loadNextPath(null);\n        };\n        /**\n         * Examine the dependencies of module 'module' and resolve them as needed.\n         */\n        ModuleManager.prototype._resolve = function (m) {\n            var _this = this;\n            var i, len, id, dependencies, dependencyId, moduleIdResolver;\n            id = m.getId();\n            dependencies = m.getDependencies();\n            moduleIdResolver = m.getModuleIdResolver();\n            this._dependencies[id] = [];\n            var loadCallback = function (moduleId) { return _this._loadModule(moduleIdResolver, moduleId); };\n            for (i = 0, len = dependencies.length; i < len; i++) {\n                dependencyId = dependencies[i];\n                if (dependencyId === 'require') {\n                    m.resolveDependency(dependencyId, this._createRequire(moduleIdResolver));\n                    continue;\n                }\n                else {\n                    if (dependencyId.indexOf('!') >= 0) {\n                        this._resolvePluginDependency(id, dependencyId);\n                    }\n                    else {\n                        this._resolveDependency(id, dependencyId, loadCallback);\n                    }\n                }\n            }\n            if (m.isComplete()) {\n                // This module was completed as soon as its been seen.\n                this._onModuleComplete(id, m.getExports());\n            }\n        };\n        return ModuleManager;\n    }());\n    AMDLoader.ModuleManager = ModuleManager;\n    /**\n     * Load `scriptSrc` only once (avoid multiple <script> tags)\n     */\n    var OnlyOnceScriptLoader = (function () {\n        function OnlyOnceScriptLoader(actualScriptLoader) {\n            this.actualScriptLoader = actualScriptLoader;\n            this.callbackMap = {};\n        }\n        OnlyOnceScriptLoader.prototype.setModuleManager = function (moduleManager) {\n            this.actualScriptLoader.setModuleManager(moduleManager);\n        };\n        OnlyOnceScriptLoader.prototype.load = function (scriptSrc, callback, errorback, recorder) {\n            var _this = this;\n            var scriptCallbacks = {\n                callback: callback,\n                errorback: errorback\n            };\n            if (this.callbackMap.hasOwnProperty(scriptSrc)) {\n                this.callbackMap[scriptSrc].push(scriptCallbacks);\n                return;\n            }\n            this.callbackMap[scriptSrc] = [scriptCallbacks];\n            this.actualScriptLoader.load(scriptSrc, function () { return _this.triggerCallback(scriptSrc); }, function (err) { return _this.triggerErrorback(scriptSrc, err); }, recorder);\n        };\n        OnlyOnceScriptLoader.prototype.triggerCallback = function (scriptSrc) {\n            var scriptCallbacks = this.callbackMap[scriptSrc];\n            delete this.callbackMap[scriptSrc];\n            for (var i = 0; i < scriptCallbacks.length; i++) {\n                scriptCallbacks[i].callback();\n            }\n        };\n        OnlyOnceScriptLoader.prototype.triggerErrorback = function (scriptSrc, err) {\n            var scriptCallbacks = this.callbackMap[scriptSrc];\n            delete this.callbackMap[scriptSrc];\n            for (var i = 0; i < scriptCallbacks.length; i++) {\n                scriptCallbacks[i].errorback(err);\n            }\n        };\n        return OnlyOnceScriptLoader;\n    }());\n    var BrowserScriptLoader = (function () {\n        function BrowserScriptLoader() {\n        }\n        /**\n         * Attach load / error listeners to a script element and remove them when either one has fired.\n         * Implemented for browssers supporting 'onreadystatechange' events, such as IE8 or IE9\n         */\n        BrowserScriptLoader.prototype.attachListenersV1 = function (script, callback, errorback) {\n            var unbind = function () {\n                script.detachEvent('onreadystatechange', loadEventListener);\n                if (script.addEventListener) {\n                    script.removeEventListener('error', errorEventListener);\n                }\n            };\n            var loadEventListener = function (e) {\n                if (script.readyState === 'loaded' || script.readyState === 'complete') {\n                    unbind();\n                    callback();\n                }\n            };\n            var errorEventListener = function (e) {\n                unbind();\n                errorback(e);\n            };\n            script.attachEvent('onreadystatechange', loadEventListener);\n            if (script.addEventListener) {\n                script.addEventListener('error', errorEventListener);\n            }\n        };\n        /**\n         * Attach load / error listeners to a script element and remove them when either one has fired.\n         * Implemented for browssers supporting HTML5 standard 'load' and 'error' events.\n         */\n        BrowserScriptLoader.prototype.attachListenersV2 = function (script, callback, errorback) {\n            var unbind = function () {\n                script.removeEventListener('load', loadEventListener);\n                script.removeEventListener('error', errorEventListener);\n            };\n            var loadEventListener = function (e) {\n                unbind();\n                callback();\n            };\n            var errorEventListener = function (e) {\n                unbind();\n                errorback(e);\n            };\n            script.addEventListener('load', loadEventListener);\n            script.addEventListener('error', errorEventListener);\n        };\n        BrowserScriptLoader.prototype.setModuleManager = function (moduleManager) {\n            /* Intentional empty */\n        };\n        BrowserScriptLoader.prototype.load = function (scriptSrc, callback, errorback) {\n            var script = document.createElement('script');\n            script.setAttribute('async', 'async');\n            script.setAttribute('type', 'text/javascript');\n            if (global.attachEvent) {\n                this.attachListenersV1(script, callback, errorback);\n            }\n            else {\n                this.attachListenersV2(script, callback, errorback);\n            }\n            script.setAttribute('src', scriptSrc);\n            document.getElementsByTagName('head')[0].appendChild(script);\n        };\n        return BrowserScriptLoader;\n    }());\n    var WorkerScriptLoader = (function () {\n        function WorkerScriptLoader() {\n            this.loadCalls = [];\n            this.loadTimeout = -1;\n        }\n        WorkerScriptLoader.prototype.setModuleManager = function (moduleManager) {\n            /* Intentional empty */\n        };\n        WorkerScriptLoader.prototype.load = function (scriptSrc, callback, errorback) {\n            var _this = this;\n            this.loadCalls.push({\n                scriptSrc: scriptSrc,\n                callback: callback,\n                errorback: errorback\n            });\n            if (navigator.userAgent.indexOf('Firefox') >= 0) {\n                // Firefox fails installing the timer every now and then :(\n                this._load();\n            }\n            else {\n                if (this.loadTimeout === -1) {\n                    this.loadTimeout = setTimeout(function () {\n                        _this.loadTimeout = -1;\n                        _this._load();\n                    }, 0);\n                }\n            }\n        };\n        WorkerScriptLoader.prototype._load = function () {\n            var loadCalls = this.loadCalls;\n            this.loadCalls = [];\n            var i, len = loadCalls.length, scripts = [];\n            for (i = 0; i < len; i++) {\n                scripts.push(loadCalls[i].scriptSrc);\n            }\n            var errorOccured = false;\n            try {\n                importScripts.apply(null, scripts);\n            }\n            catch (e) {\n                errorOccured = true;\n                for (i = 0; i < len; i++) {\n                    loadCalls[i].errorback(e);\n                }\n            }\n            if (!errorOccured) {\n                for (i = 0; i < len; i++) {\n                    loadCalls[i].callback();\n                }\n            }\n        };\n        return WorkerScriptLoader;\n    }());\n    var NodeScriptLoader = (function () {\n        function NodeScriptLoader() {\n            this._initialized = false;\n        }\n        NodeScriptLoader.prototype.setModuleManager = function (moduleManager) {\n            this._moduleManager = moduleManager;\n        };\n        NodeScriptLoader.prototype._init = function (nodeRequire) {\n            if (this._initialized) {\n                return;\n            }\n            this._initialized = true;\n            this._fs = nodeRequire('fs');\n            this._vm = nodeRequire('vm');\n            this._path = nodeRequire('path');\n        };\n        NodeScriptLoader.prototype.load = function (scriptSrc, callback, errorback, recorder) {\n            var _this = this;\n            var opts = this._moduleManager.getConfigurationOptions();\n            var nodeRequire = (opts.nodeRequire || global.nodeRequire);\n            var nodeInstrumenter = (opts.nodeInstrumenter || function (c) { return c; });\n            this._init(nodeRequire);\n            if (/^node\\|/.test(scriptSrc)) {\n                var pieces = scriptSrc.split('|');\n                var moduleExports = null;\n                try {\n                    recorder.record(LoaderEventType.NodeBeginNativeRequire, pieces[2]);\n                    moduleExports = nodeRequire(pieces[2]);\n                }\n                catch (err) {\n                    recorder.record(LoaderEventType.NodeEndNativeRequire, pieces[2]);\n                    errorback(err);\n                    return;\n                }\n                recorder.record(LoaderEventType.NodeEndNativeRequire, pieces[2]);\n                this._moduleManager.enqueueDefineAnonymousModule([], function () { return moduleExports; });\n                callback();\n            }\n            else {\n                scriptSrc = Utilities.fileUriToFilePath(scriptSrc);\n                this._fs.readFile(scriptSrc, { encoding: 'utf8' }, function (err, data) {\n                    if (err) {\n                        errorback(err);\n                        return;\n                    }\n                    recorder.record(LoaderEventType.NodeBeginEvaluatingScript, scriptSrc);\n                    var vmScriptSrc = _this._path.normalize(scriptSrc);\n                    // Make the script src friendly towards electron\n                    if (isElectronRenderer) {\n                        var driveLetterMatch = vmScriptSrc.match(/^([a-z])\\:(.*)/);\n                        if (driveLetterMatch) {\n                            vmScriptSrc = driveLetterMatch[1].toUpperCase() + ':' + driveLetterMatch[2];\n                        }\n                        vmScriptSrc = 'file:///' + vmScriptSrc.replace(/\\\\/g, '/');\n                    }\n                    var contents, prefix = '(function (require, define, __filename, __dirname) { ', suffix = '\\n});';\n                    if (data.charCodeAt(0) === NodeScriptLoader._BOM) {\n                        contents = prefix + data.substring(1) + suffix;\n                    }\n                    else {\n                        contents = prefix + data + suffix;\n                    }\n                    contents = nodeInstrumenter(contents, vmScriptSrc);\n                    var r;\n                    if (/^v0\\.12/.test(process.version)) {\n                        r = _this._vm.runInThisContext(contents, { filename: vmScriptSrc });\n                    }\n                    else {\n                        r = _this._vm.runInThisContext(contents, vmScriptSrc);\n                    }\n                    r.call(global, RequireFunc, DefineFunc, vmScriptSrc, _this._path.dirname(scriptSrc));\n                    recorder.record(LoaderEventType.NodeEndEvaluatingScript, scriptSrc);\n                    callback();\n                });\n            }\n        };\n        NodeScriptLoader._BOM = 0xFEFF;\n        return NodeScriptLoader;\n    }());\n    // ------------------------------------------------------------------------\n    // ------------------------------------------------------------------------\n    // ------------------------------------------------------------------------\n    // define\n    var DefineFunc = (function () {\n        function DefineFunc(id, dependencies, callback) {\n            if (typeof id !== 'string') {\n                callback = dependencies;\n                dependencies = id;\n                id = null;\n            }\n            if (typeof dependencies !== 'object' || !Utilities.isArray(dependencies)) {\n                callback = dependencies;\n                dependencies = null;\n            }\n            if (!dependencies) {\n                dependencies = ['require', 'exports', 'module'];\n            }\n            if (id) {\n                moduleManager.enqueueDefineModule(id, dependencies, callback);\n            }\n            else {\n                moduleManager.enqueueDefineAnonymousModule(dependencies, callback);\n            }\n        }\n        DefineFunc.amd = {\n            jQuery: true\n        };\n        return DefineFunc;\n    }());\n    var RequireFunc = (function () {\n        function RequireFunc() {\n            if (arguments.length === 1) {\n                if ((arguments[0] instanceof Object) && !Utilities.isArray(arguments[0])) {\n                    RequireFunc.config(arguments[0]);\n                    return;\n                }\n                if (typeof arguments[0] === 'string') {\n                    return moduleManager.synchronousRequire(arguments[0]);\n                }\n            }\n            if (arguments.length === 2 || arguments.length === 3) {\n                if (Utilities.isArray(arguments[0])) {\n                    moduleManager.defineModule(Utilities.generateAnonymousModule(), arguments[0], arguments[1], arguments[2], null);\n                    return;\n                }\n            }\n            throw new Error('Unrecognized require call');\n        }\n        RequireFunc.config = function (params, shouldOverwrite) {\n            if (shouldOverwrite === void 0) { shouldOverwrite = false; }\n            moduleManager.configure(params, shouldOverwrite);\n        };\n        RequireFunc.getConfig = function () {\n            return moduleManager.getConfigurationOptions();\n        };\n        /**\n         * Non standard extension to reset completely the loader state. This is used for running amdjs tests\n         */\n        RequireFunc.reset = function () {\n            moduleManager = new ModuleManager(scriptLoader);\n            scriptLoader.setModuleManager(moduleManager);\n        };\n        /**\n         * Non standard extension to fetch loader state for building purposes.\n         */\n        RequireFunc.getBuildInfo = function () {\n            return moduleManager.getBuildInfo();\n        };\n        /**\n         * Non standard extension to fetch loader events\n         */\n        RequireFunc.getStats = function () {\n            return moduleManager.getLoaderEvents();\n        };\n        return RequireFunc;\n    }());\n    var global = _amdLoaderGlobal, hasPerformanceNow = (global.performance && typeof global.performance.now === 'function'), isWebWorker, isElectronRenderer, isElectronMain, isNode, scriptLoader, moduleManager, loaderAvailableTimestamp;\n    function initVars() {\n        isWebWorker = (typeof global.importScripts === 'function');\n        isElectronRenderer = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions['electron'] !== 'undefined' && process.type === 'renderer');\n        isElectronMain = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions['electron'] !== 'undefined' && process.type === 'browser');\n        isNode = (typeof module !== 'undefined' && !!module.exports);\n        if (isWebWorker) {\n            scriptLoader = new OnlyOnceScriptLoader(new WorkerScriptLoader());\n        }\n        else if (isNode) {\n            scriptLoader = new OnlyOnceScriptLoader(new NodeScriptLoader());\n        }\n        else {\n            scriptLoader = new OnlyOnceScriptLoader(new BrowserScriptLoader());\n        }\n        moduleManager = new ModuleManager(scriptLoader);\n        scriptLoader.setModuleManager(moduleManager);\n    }\n    function initConsole() {\n        // Define used console.* functions, in order to not fail in environments where they are not available\n        if (!isNode) {\n            if (!global.console) {\n                global.console = {};\n            }\n            if (!global.console.log) {\n                global.console.log = function () { };\n            }\n            if (!global.console.warn) {\n                global.console.warn = global.console.log;\n            }\n            if (!global.console.error) {\n                global.console.error = global.console.log;\n            }\n        }\n    }\n    function initMainScript() {\n        if (!isWebWorker && !isNode) {\n            window.onload = function () {\n                var i, len, main, scripts = document.getElementsByTagName('script');\n                // Look through all the scripts for the data-main attribute\n                for (i = 0, len = scripts.length; i < len; i++) {\n                    main = scripts[i].getAttribute('data-main');\n                    if (main) {\n                        break;\n                    }\n                }\n                // Load the main script\n                if (main) {\n                    moduleManager.defineModule(Utilities.generateAnonymousModule(), [main], null, null, null, new ModuleIdResolver(new Configuration(), ''));\n                }\n            };\n        }\n    }\n    function init() {\n        initVars();\n        initConsole();\n        initMainScript();\n        if (isNode) {\n            var _nodeRequire = (global.require || require);\n            var nodeRequire = function (what) {\n                moduleManager.getRecorder().record(LoaderEventType.NodeBeginNativeRequire, what);\n                var r = _nodeRequire(what);\n                moduleManager.getRecorder().record(LoaderEventType.NodeEndNativeRequire, what);\n                return r;\n            };\n            global.nodeRequire = nodeRequire;\n            RequireFunc.nodeRequire = nodeRequire;\n        }\n        if (isNode && !isElectronRenderer) {\n            module.exports = RequireFunc;\n            // These two defs are fore the local closure defined in node in the case that the loader is concatenated\n            define = function () {\n                DefineFunc.apply(null, arguments);\n            };\n            require = RequireFunc;\n        }\n        else {\n            // The global variable require can configure the loader\n            if (typeof global.require !== 'undefined' && typeof global.require !== 'function') {\n                RequireFunc.config(global.require);\n            }\n            if (!isElectronRenderer) {\n                global.define = DefineFunc;\n            }\n            else {\n                define = function () {\n                    DefineFunc.apply(null, arguments);\n                };\n            }\n            global.require = RequireFunc;\n            global.require.__$__nodeRequire = nodeRequire;\n        }\n    }\n    if (typeof global.define !== 'function' || !global.define.amd) {\n        init();\n        loaderAvailableTimestamp = getHighPerformanceTimestamp();\n    }\n})(AMDLoader || (AMDLoader = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/*---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n * Please make sure to make edits in the .ts file at https://github.com/Microsoft/vscode-loader/\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar _cssPluginGlobal = this;\nvar CSSLoaderPlugin;\n(function (CSSLoaderPlugin) {\n    var global = _cssPluginGlobal;\n    /**\n     * Known issue:\n     * - In IE there is no way to know if the CSS file loaded successfully or not.\n     */\n    var BrowserCSSLoader = (function () {\n        function BrowserCSSLoader() {\n            this._pendingLoads = 0;\n        }\n        BrowserCSSLoader.prototype.attachListeners = function (name, linkNode, callback, errorback) {\n            var unbind = function () {\n                linkNode.removeEventListener('load', loadEventListener);\n                linkNode.removeEventListener('error', errorEventListener);\n            };\n            var loadEventListener = function (e) {\n                unbind();\n                callback();\n            };\n            var errorEventListener = function (e) {\n                unbind();\n                errorback(e);\n            };\n            linkNode.addEventListener('load', loadEventListener);\n            linkNode.addEventListener('error', errorEventListener);\n        };\n        BrowserCSSLoader.prototype._onLoad = function (name, callback) {\n            this._pendingLoads--;\n            callback();\n        };\n        BrowserCSSLoader.prototype._onLoadError = function (name, errorback, err) {\n            this._pendingLoads--;\n            errorback(err);\n        };\n        BrowserCSSLoader.prototype._insertLinkNode = function (linkNode) {\n            this._pendingLoads++;\n            var head = document.head || document.getElementsByTagName('head')[0];\n            var other = head.getElementsByTagName('link') || document.head.getElementsByTagName('script');\n            if (other.length > 0) {\n                head.insertBefore(linkNode, other[other.length - 1]);\n            }\n            else {\n                head.appendChild(linkNode);\n            }\n        };\n        BrowserCSSLoader.prototype.createLinkTag = function (name, cssUrl, externalCallback, externalErrorback) {\n            var _this = this;\n            var linkNode = document.createElement('link');\n            linkNode.setAttribute('rel', 'stylesheet');\n            linkNode.setAttribute('type', 'text/css');\n            linkNode.setAttribute('data-name', name);\n            var callback = function () { return _this._onLoad(name, externalCallback); };\n            var errorback = function (err) { return _this._onLoadError(name, externalErrorback, err); };\n            this.attachListeners(name, linkNode, callback, errorback);\n            linkNode.setAttribute('href', cssUrl);\n            return linkNode;\n        };\n        BrowserCSSLoader.prototype._linkTagExists = function (name, cssUrl) {\n            var i, len, nameAttr, hrefAttr, links = document.getElementsByTagName('link');\n            for (i = 0, len = links.length; i < len; i++) {\n                nameAttr = links[i].getAttribute('data-name');\n                hrefAttr = links[i].getAttribute('href');\n                if (nameAttr === name || hrefAttr === cssUrl) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        BrowserCSSLoader.prototype.load = function (name, cssUrl, externalCallback, externalErrorback) {\n            if (this._linkTagExists(name, cssUrl)) {\n                externalCallback();\n                return;\n            }\n            var linkNode = this.createLinkTag(name, cssUrl, externalCallback, externalErrorback);\n            this._insertLinkNode(linkNode);\n        };\n        return BrowserCSSLoader;\n    }());\n    /**\n     * Prior to IE10, IE could not go above 31 stylesheets in a page\n     * http://blogs.msdn.com/b/ieinternals/archive/2011/05/14/internet-explorer-stylesheet-rule-selector-import-sheet-limit-maximum.aspx\n     *\n     * The general strategy here is to not write more than 31 link nodes to the page at the same time\n     * When stylesheets get loaded, they will get merged one into another to free up\n     * some positions for new link nodes.\n     */\n    var IE9CSSLoader = (function (_super) {\n        __extends(IE9CSSLoader, _super);\n        function IE9CSSLoader() {\n            _super.call(this);\n            this._blockedLoads = [];\n            this._mergeStyleSheetsTimeout = -1;\n        }\n        IE9CSSLoader.prototype.load = function (name, cssUrl, externalCallback, externalErrorback) {\n            if (this._linkTagExists(name, cssUrl)) {\n                externalCallback();\n                return;\n            }\n            var linkNode = this.createLinkTag(name, cssUrl, externalCallback, externalErrorback);\n            if (this._styleSheetCount() < 31) {\n                this._insertLinkNode(linkNode);\n            }\n            else {\n                this._blockedLoads.push(linkNode);\n                this._handleBlocked();\n            }\n        };\n        IE9CSSLoader.prototype._styleSheetCount = function () {\n            var linkCount = document.getElementsByTagName('link').length;\n            var styleCount = document.getElementsByTagName('style').length;\n            return linkCount + styleCount;\n        };\n        IE9CSSLoader.prototype._onLoad = function (name, callback) {\n            _super.prototype._onLoad.call(this, name, callback);\n            this._handleBlocked();\n        };\n        IE9CSSLoader.prototype._onLoadError = function (name, errorback, err) {\n            _super.prototype._onLoadError.call(this, name, errorback, err);\n            this._handleBlocked();\n        };\n        IE9CSSLoader.prototype._handleBlocked = function () {\n            var _this = this;\n            var blockedLoadsCount = this._blockedLoads.length;\n            if (blockedLoadsCount > 0 && this._mergeStyleSheetsTimeout === -1) {\n                this._mergeStyleSheetsTimeout = window.setTimeout(function () { return _this._mergeStyleSheets(); }, 0);\n            }\n        };\n        IE9CSSLoader.prototype._mergeStyleSheet = function (dstPath, dst, srcPath, src) {\n            for (var i = src.rules.length - 1; i >= 0; i--) {\n                dst.insertRule(Utilities.rewriteUrls(srcPath, dstPath, src.rules[i].cssText), 0);\n            }\n        };\n        IE9CSSLoader.prototype._asIE9HTMLLinkElement = function (linkElement) {\n            return linkElement;\n        };\n        IE9CSSLoader.prototype._mergeStyleSheets = function () {\n            this._mergeStyleSheetsTimeout = -1;\n            var blockedLoadsCount = this._blockedLoads.length;\n            var i, linkDomNodes = document.getElementsByTagName('link');\n            var linkDomNodesCount = linkDomNodes.length;\n            var mergeCandidates = [];\n            for (i = 0; i < linkDomNodesCount; i++) {\n                if (linkDomNodes[i].readyState === 'loaded' || linkDomNodes[i].readyState === 'complete') {\n                    mergeCandidates.push({\n                        linkNode: linkDomNodes[i],\n                        rulesLength: this._asIE9HTMLLinkElement(linkDomNodes[i]).styleSheet.rules.length\n                    });\n                }\n            }\n            var mergeCandidatesCount = mergeCandidates.length;\n            // Just a little legend here :)\n            // - linkDomNodesCount: total number of link nodes in the DOM (this should be kept <= 31)\n            // - mergeCandidatesCount: loaded (finished) link nodes in the DOM (only these can be merged)\n            // - blockedLoadsCount: remaining number of load requests that did not fit in before (because of the <= 31 constraint)\n            // Now comes the heuristic part, we don't want to do too much work with the merging of styles,\n            // but we do need to merge stylesheets to free up loading slots.\n            var mergeCount = Math.min(Math.floor(mergeCandidatesCount / 2), blockedLoadsCount);\n            // Sort the merge candidates descending (least rules last)\n            mergeCandidates.sort(function (a, b) {\n                return b.rulesLength - a.rulesLength;\n            });\n            var srcIndex, dstIndex;\n            for (i = 0; i < mergeCount; i++) {\n                srcIndex = mergeCandidates.length - 1 - i;\n                dstIndex = i % (mergeCandidates.length - mergeCount);\n                // Merge rules of src into dst\n                this._mergeStyleSheet(mergeCandidates[dstIndex].linkNode.href, this._asIE9HTMLLinkElement(mergeCandidates[dstIndex].linkNode).styleSheet, mergeCandidates[srcIndex].linkNode.href, this._asIE9HTMLLinkElement(mergeCandidates[srcIndex].linkNode).styleSheet);\n                // Remove dom node of src\n                mergeCandidates[srcIndex].linkNode.parentNode.removeChild(mergeCandidates[srcIndex].linkNode);\n                linkDomNodesCount--;\n            }\n            var styleSheetCount = this._styleSheetCount();\n            while (styleSheetCount < 31 && this._blockedLoads.length > 0) {\n                this._insertLinkNode(this._blockedLoads.shift());\n                styleSheetCount++;\n            }\n        };\n        return IE9CSSLoader;\n    }(BrowserCSSLoader));\n    var IE8CSSLoader = (function (_super) {\n        __extends(IE8CSSLoader, _super);\n        function IE8CSSLoader() {\n            _super.call(this);\n        }\n        IE8CSSLoader.prototype.attachListeners = function (name, linkNode, callback, errorback) {\n            linkNode.onload = function () {\n                linkNode.onload = null;\n                callback();\n            };\n        };\n        return IE8CSSLoader;\n    }(IE9CSSLoader));\n    var NodeCSSLoader = (function () {\n        function NodeCSSLoader() {\n            this.fs = require.nodeRequire('fs');\n        }\n        NodeCSSLoader.prototype.load = function (name, cssUrl, externalCallback, externalErrorback) {\n            var contents = this.fs.readFileSync(cssUrl, 'utf8');\n            // Remove BOM\n            if (contents.charCodeAt(0) === NodeCSSLoader.BOM_CHAR_CODE) {\n                contents = contents.substring(1);\n            }\n            externalCallback(contents);\n        };\n        NodeCSSLoader.BOM_CHAR_CODE = 65279;\n        return NodeCSSLoader;\n    }());\n    // ------------------------------ Finally, the plugin\n    var CSSPlugin = (function () {\n        function CSSPlugin(cssLoader) {\n            this.cssLoader = cssLoader;\n        }\n        CSSPlugin.prototype.load = function (name, req, load, config) {\n            config = config || {};\n            var myConfig = config['vs/css'] || {};\n            global.inlineResources = myConfig.inlineResources;\n            var cssUrl = req.toUrl(name + '.css');\n            this.cssLoader.load(name, cssUrl, function (contents) {\n                // Contents has the CSS file contents if we are in a build\n                if (config.isBuild) {\n                    CSSPlugin.BUILD_MAP[name] = contents;\n                    CSSPlugin.BUILD_PATH_MAP[name] = cssUrl;\n                }\n                load({});\n            }, function (err) {\n                if (typeof load.error === 'function') {\n                    load.error('Could not find ' + cssUrl + ' or it was empty');\n                }\n            });\n        };\n        CSSPlugin.prototype.write = function (pluginName, moduleName, write) {\n            // getEntryPoint is a Monaco extension to r.js\n            var entryPoint = write.getEntryPoint();\n            // r.js destroys the context of this plugin between calling 'write' and 'writeFile'\n            // so the only option at this point is to leak the data to a global\n            global.cssPluginEntryPoints = global.cssPluginEntryPoints || {};\n            global.cssPluginEntryPoints[entryPoint] = global.cssPluginEntryPoints[entryPoint] || [];\n            global.cssPluginEntryPoints[entryPoint].push({\n                moduleName: moduleName,\n                contents: CSSPlugin.BUILD_MAP[moduleName],\n                fsPath: CSSPlugin.BUILD_PATH_MAP[moduleName],\n            });\n            write.asModule(pluginName + '!' + moduleName, 'define([\\'vs/css!' + entryPoint + '\\'], {});');\n        };\n        CSSPlugin.prototype.writeFile = function (pluginName, moduleName, req, write, config) {\n            if (global.cssPluginEntryPoints && global.cssPluginEntryPoints.hasOwnProperty(moduleName)) {\n                var fileName = req.toUrl(moduleName + '.css');\n                var contents = [\n                    '/*---------------------------------------------------------',\n                    ' * Copyright (c) Microsoft Corporation. All rights reserved.',\n                    ' *--------------------------------------------------------*/'\n                ], entries = global.cssPluginEntryPoints[moduleName];\n                for (var i = 0; i < entries.length; i++) {\n                    if (global.inlineResources) {\n                        contents.push(Utilities.rewriteOrInlineUrls(entries[i].fsPath, entries[i].moduleName, moduleName, entries[i].contents, global.inlineResources === 'base64'));\n                    }\n                    else {\n                        contents.push(Utilities.rewriteUrls(entries[i].moduleName, moduleName, entries[i].contents));\n                    }\n                }\n                write(fileName, contents.join('\\r\\n'));\n            }\n        };\n        CSSPlugin.prototype.getInlinedResources = function () {\n            return global.cssInlinedResources || [];\n        };\n        CSSPlugin.BUILD_MAP = {};\n        CSSPlugin.BUILD_PATH_MAP = {};\n        return CSSPlugin;\n    }());\n    CSSLoaderPlugin.CSSPlugin = CSSPlugin;\n    var Utilities = (function () {\n        function Utilities() {\n        }\n        Utilities.startsWith = function (haystack, needle) {\n            return haystack.length >= needle.length && haystack.substr(0, needle.length) === needle;\n        };\n        /**\n         * Find the path of a file.\n         */\n        Utilities.pathOf = function (filename) {\n            var lastSlash = filename.lastIndexOf('/');\n            if (lastSlash !== -1) {\n                return filename.substr(0, lastSlash + 1);\n            }\n            else {\n                return '';\n            }\n        };\n        /**\n         * A conceptual a + b for paths.\n         * Takes into account if `a` contains a protocol.\n         * Also normalizes the result: e.g.: a/b/ + ../c => a/c\n         */\n        Utilities.joinPaths = function (a, b) {\n            function findSlashIndexAfterPrefix(haystack, prefix) {\n                if (Utilities.startsWith(haystack, prefix)) {\n                    return Math.max(prefix.length, haystack.indexOf('/', prefix.length));\n                }\n                return 0;\n            }\n            var aPathStartIndex = 0;\n            aPathStartIndex = aPathStartIndex || findSlashIndexAfterPrefix(a, '//');\n            aPathStartIndex = aPathStartIndex || findSlashIndexAfterPrefix(a, 'http://');\n            aPathStartIndex = aPathStartIndex || findSlashIndexAfterPrefix(a, 'https://');\n            function pushPiece(pieces, piece) {\n                if (piece === './') {\n                    // Ignore\n                    return;\n                }\n                if (piece === '../') {\n                    var prevPiece = (pieces.length > 0 ? pieces[pieces.length - 1] : null);\n                    if (prevPiece && prevPiece === '/') {\n                        // Ignore\n                        return;\n                    }\n                    if (prevPiece && prevPiece !== '../') {\n                        // Pop\n                        pieces.pop();\n                        return;\n                    }\n                }\n                // Push\n                pieces.push(piece);\n            }\n            function push(pieces, path) {\n                while (path.length > 0) {\n                    var slashIndex = path.indexOf('/');\n                    var piece = (slashIndex >= 0 ? path.substring(0, slashIndex + 1) : path);\n                    path = (slashIndex >= 0 ? path.substring(slashIndex + 1) : '');\n                    pushPiece(pieces, piece);\n                }\n            }\n            var pieces = [];\n            push(pieces, a.substr(aPathStartIndex));\n            if (b.length > 0 && b.charAt(0) === '/') {\n                pieces = [];\n            }\n            push(pieces, b);\n            return a.substring(0, aPathStartIndex) + pieces.join('');\n        };\n        Utilities.commonPrefix = function (str1, str2) {\n            var len = Math.min(str1.length, str2.length);\n            for (var i = 0; i < len; i++) {\n                if (str1.charCodeAt(i) !== str2.charCodeAt(i)) {\n                    break;\n                }\n            }\n            return str1.substring(0, i);\n        };\n        Utilities.commonFolderPrefix = function (fromPath, toPath) {\n            var prefix = Utilities.commonPrefix(fromPath, toPath);\n            var slashIndex = prefix.lastIndexOf('/');\n            if (slashIndex === -1) {\n                return '';\n            }\n            return prefix.substring(0, slashIndex + 1);\n        };\n        Utilities.relativePath = function (fromPath, toPath) {\n            if (Utilities.startsWith(toPath, '/') || Utilities.startsWith(toPath, 'http://') || Utilities.startsWith(toPath, 'https://')) {\n                return toPath;\n            }\n            // Ignore common folder prefix\n            var prefix = Utilities.commonFolderPrefix(fromPath, toPath);\n            fromPath = fromPath.substr(prefix.length);\n            toPath = toPath.substr(prefix.length);\n            var upCount = fromPath.split('/').length;\n            var result = '';\n            for (var i = 1; i < upCount; i++) {\n                result += '../';\n            }\n            return result + toPath;\n        };\n        Utilities._replaceURL = function (contents, replacer) {\n            // Use \")\" as the terminator as quotes are oftentimes not used at all\n            return contents.replace(/url\\(\\s*([^\\)]+)\\s*\\)?/g, function (_) {\n                var matches = [];\n                for (var _i = 1; _i < arguments.length; _i++) {\n                    matches[_i - 1] = arguments[_i];\n                }\n                var url = matches[0];\n                // Eliminate starting quotes (the initial whitespace is not captured)\n                if (url.charAt(0) === '\"' || url.charAt(0) === '\\'') {\n                    url = url.substring(1);\n                }\n                // The ending whitespace is captured\n                while (url.length > 0 && (url.charAt(url.length - 1) === ' ' || url.charAt(url.length - 1) === '\\t')) {\n                    url = url.substring(0, url.length - 1);\n                }\n                // Eliminate ending quotes\n                if (url.charAt(url.length - 1) === '\"' || url.charAt(url.length - 1) === '\\'') {\n                    url = url.substring(0, url.length - 1);\n                }\n                if (!Utilities.startsWith(url, 'data:') && !Utilities.startsWith(url, 'http://') && !Utilities.startsWith(url, 'https://')) {\n                    url = replacer(url);\n                }\n                return 'url(' + url + ')';\n            });\n        };\n        Utilities.rewriteUrls = function (originalFile, newFile, contents) {\n            return this._replaceURL(contents, function (url) {\n                var absoluteUrl = Utilities.joinPaths(Utilities.pathOf(originalFile), url);\n                return Utilities.relativePath(newFile, absoluteUrl);\n            });\n        };\n        Utilities.rewriteOrInlineUrls = function (originalFileFSPath, originalFile, newFile, contents, forceBase64) {\n            var fs = require.nodeRequire('fs');\n            var path = require.nodeRequire('path');\n            return this._replaceURL(contents, function (url) {\n                if (/\\.(svg|png)$/.test(url)) {\n                    var fsPath = path.join(path.dirname(originalFileFSPath), url);\n                    var fileContents = fs.readFileSync(fsPath);\n                    if (fileContents.length < 3000) {\n                        global.cssInlinedResources = global.cssInlinedResources || [];\n                        var normalizedFSPath = fsPath.replace(/\\\\/g, '/');\n                        if (global.cssInlinedResources.indexOf(normalizedFSPath) >= 0) {\n                            console.warn('CSS INLINING IMAGE AT ' + fsPath + ' MORE THAN ONCE. CONSIDER CONSOLIDATING CSS RULES');\n                        }\n                        global.cssInlinedResources.push(normalizedFSPath);\n                        var MIME = /\\.svg$/.test(url) ? 'image/svg+xml' : 'image/png';\n                        var DATA = ';base64,' + fileContents.toString('base64');\n                        if (!forceBase64 && /\\.svg$/.test(url)) {\n                            // .svg => url encode as explained at https://codepen.io/tigt/post/optimizing-svgs-in-data-uris\n                            var newText = fileContents.toString()\n                                .replace(/\"/g, '\\'')\n                                .replace(/</g, '%3C')\n                                .replace(/>/g, '%3E')\n                                .replace(/&/g, '%26')\n                                .replace(/#/g, '%23')\n                                .replace(/\\s+/g, ' ');\n                            var encodedData = ',' + newText;\n                            if (encodedData.length < DATA.length) {\n                                DATA = encodedData;\n                            }\n                        }\n                        return '\"data:' + MIME + DATA + '\"';\n                    }\n                }\n                var absoluteUrl = Utilities.joinPaths(Utilities.pathOf(originalFile), url);\n                return Utilities.relativePath(newFile, absoluteUrl);\n            });\n        };\n        return Utilities;\n    }());\n    CSSLoaderPlugin.Utilities = Utilities;\n    (function () {\n        var cssLoader = null;\n        var isElectron = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions['electron'] !== 'undefined');\n        if (typeof process !== 'undefined' && process.versions && !!process.versions.node && !isElectron) {\n            cssLoader = new NodeCSSLoader();\n        }\n        else if (typeof navigator !== 'undefined' && navigator.userAgent.indexOf('MSIE 9') >= 0) {\n            cssLoader = new IE9CSSLoader();\n        }\n        else if (typeof navigator !== 'undefined' && navigator.userAgent.indexOf('MSIE 8') >= 0) {\n            cssLoader = new IE8CSSLoader();\n        }\n        else {\n            cssLoader = new BrowserCSSLoader();\n        }\n        define('vs/css', new CSSPlugin(cssLoader));\n    })();\n})(CSSLoaderPlugin || (CSSLoaderPlugin = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/*---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n * Please make sure to make edits in the .ts file at https://github.com/Microsoft/vscode-loader/\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *---------------------------------------------------------------------------------------------\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nvar _nlsPluginGlobal = this;\nvar NLSLoaderPlugin;\n(function (NLSLoaderPlugin) {\n    var global = _nlsPluginGlobal;\n    var Resources = global.Plugin && global.Plugin.Resources ? global.Plugin.Resources : undefined;\n    var DEFAULT_TAG = 'i-default';\n    var IS_PSEUDO = (global && global.document && global.document.location && global.document.location.hash.indexOf('pseudo=true') >= 0);\n    var slice = Array.prototype.slice;\n    function _format(message, args) {\n        var result;\n        if (args.length === 0) {\n            result = message;\n        }\n        else {\n            result = message.replace(/\\{(\\d+)\\}/g, function (match, rest) {\n                var index = rest[0];\n                return typeof args[index] !== 'undefined' ? args[index] : match;\n            });\n        }\n        if (IS_PSEUDO) {\n            // FF3B and FF3D is the Unicode zenkaku representation for [ and ]\n            result = '\\uFF3B' + result.replace(/[aouei]/g, '$&$&') + '\\uFF3D';\n        }\n        return result;\n    }\n    function findLanguageForModule(config, name) {\n        var result = config[name];\n        if (result)\n            return result;\n        result = config['*'];\n        if (result)\n            return result;\n        return null;\n    }\n    function localize(data, message) {\n        var args = [];\n        for (var _i = 0; _i < (arguments.length - 2); _i++) {\n            args[_i] = arguments[_i + 2];\n        }\n        return _format(message, args);\n    }\n    function createScopedLocalize(scope) {\n        return function (idx, defaultValue) {\n            var restArgs = slice.call(arguments, 2);\n            return _format(scope[idx], restArgs);\n        };\n    }\n    var NLSPlugin = (function () {\n        function NLSPlugin() {\n            this.localize = localize;\n        }\n        NLSPlugin.prototype.setPseudoTranslation = function (value) {\n            IS_PSEUDO = value;\n        };\n        NLSPlugin.prototype.create = function (key, data) {\n            return {\n                localize: createScopedLocalize(data[key])\n            };\n        };\n        NLSPlugin.prototype.load = function (name, req, load, config) {\n            config = config || {};\n            if (!name || name.length === 0) {\n                load({\n                    localize: localize\n                });\n            }\n            else {\n                var suffix = void 0;\n                if (Resources && Resources.getString) {\n                    suffix = '.nls.keys';\n                    req([name + suffix], function (keyMap) {\n                        load({\n                            localize: function (moduleKey, index) {\n                                if (!keyMap[moduleKey])\n                                    return 'NLS error: unknown key ' + moduleKey;\n                                var mk = keyMap[moduleKey].keys;\n                                if (index >= mk.length)\n                                    return 'NLS error unknow index ' + index;\n                                var subKey = mk[index];\n                                var args = [];\n                                args[0] = moduleKey + '_' + subKey;\n                                for (var _i = 0; _i < (arguments.length - 2); _i++) {\n                                    args[_i + 1] = arguments[_i + 2];\n                                }\n                                return Resources.getString.apply(Resources, args);\n                            }\n                        });\n                    });\n                }\n                else {\n                    if (config.isBuild) {\n                        req([name + '.nls', name + '.nls.keys'], function (messages, keys) {\n                            NLSPlugin.BUILD_MAP[name] = messages;\n                            NLSPlugin.BUILD_MAP_KEYS[name] = keys;\n                            load(messages);\n                        });\n                    }\n                    else {\n                        var pluginConfig = config['vs/nls'] || {};\n                        var language = pluginConfig.availableLanguages ? findLanguageForModule(pluginConfig.availableLanguages, name) : null;\n                        suffix = '.nls';\n                        if (language !== null && language !== DEFAULT_TAG) {\n                            suffix = suffix + '.' + language;\n                        }\n                        req([name + suffix], function (messages) {\n                            if (Array.isArray(messages)) {\n                                messages.localize = createScopedLocalize(messages);\n                            }\n                            else {\n                                messages.localize = createScopedLocalize(messages[name]);\n                            }\n                            load(messages);\n                        });\n                    }\n                }\n            }\n        };\n        NLSPlugin.prototype._getEntryPointsMap = function () {\n            global.nlsPluginEntryPoints = global.nlsPluginEntryPoints || {};\n            return global.nlsPluginEntryPoints;\n        };\n        NLSPlugin.prototype.write = function (pluginName, moduleName, write) {\n            // getEntryPoint is a Monaco extension to r.js\n            var entryPoint = write.getEntryPoint();\n            // r.js destroys the context of this plugin between calling 'write' and 'writeFile'\n            // so the only option at this point is to leak the data to a global\n            var entryPointsMap = this._getEntryPointsMap();\n            entryPointsMap[entryPoint] = entryPointsMap[entryPoint] || [];\n            entryPointsMap[entryPoint].push(moduleName);\n            if (moduleName !== entryPoint) {\n                write.asModule(pluginName + '!' + moduleName, 'define([\\'vs/nls\\', \\'vs/nls!' + entryPoint + '\\'], function(nls, data) { return nls.create(\"' + moduleName + '\", data); });');\n            }\n        };\n        NLSPlugin.prototype.writeFile = function (pluginName, moduleName, req, write, config) {\n            var entryPointsMap = this._getEntryPointsMap();\n            if (entryPointsMap.hasOwnProperty(moduleName)) {\n                var fileName = req.toUrl(moduleName + '.nls.js');\n                var contents = [\n                    '/*---------------------------------------------------------',\n                    ' * Copyright (c) Microsoft Corporation. All rights reserved.',\n                    ' *--------------------------------------------------------*/'\n                ], entries = entryPointsMap[moduleName];\n                var data = {};\n                for (var i = 0; i < entries.length; i++) {\n                    data[entries[i]] = NLSPlugin.BUILD_MAP[entries[i]];\n                }\n                contents.push('define(\"' + moduleName + '.nls\", ' + JSON.stringify(data, null, '\\t') + ');');\n                write(fileName, contents.join('\\r\\n'));\n            }\n        };\n        NLSPlugin.prototype.finishBuild = function (write) {\n            write('nls.metadata.json', JSON.stringify({\n                keys: NLSPlugin.BUILD_MAP_KEYS,\n                messages: NLSPlugin.BUILD_MAP,\n                bundles: this._getEntryPointsMap()\n            }, null, '\\t'));\n        };\n        ;\n        NLSPlugin.BUILD_MAP = {};\n        NLSPlugin.BUILD_MAP_KEYS = {};\n        return NLSPlugin;\n    }());\n    NLSLoaderPlugin.NLSPlugin = NLSPlugin;\n    (function () {\n        define('vs/nls', new NLSPlugin());\n    })();\n})(NLSLoaderPlugin || (NLSLoaderPlugin = {}));\n"]}